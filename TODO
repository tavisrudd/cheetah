Cheetah TODO list
-----------------

* If you are working on a task please put your initials at the end of the
  description

* When a task is completed please remember to note it in the CHANGES file

Languague Specification
================================================================================

- revisit parsed #include directives.  Are they necessary at all??
  (This is a rhetorical question.  They are necessary.  However, the
  Users' Guide needs better examples about when and when not to use
  #include.  Also, consider making '#include' do a raw include, and
  something else do a parsed include ('#include parsed', '#include cheetah'?),
  so that users get parsing only if they explicitly request it.

- write a formalized grammar for Cheetah in BNF 

Implementation
================================================================================

- implement some better error handling for misformed #for, #if, #try directives,
  etc.  At the moment these errors are not caught until Python executes the
  code.

- create better error message for bad code such as:
  ##cache
  This is a cached region.  $voom
  #end cache

- fix bug in Parser.getDefArgList() that is mucking up lists where the comma has
  been forgotten:

  > #cache timer='.5m' id='cache1'
  > This is a cached region.  $voom
  > #end cache
  > 
  > the error is:
  > 
  > "/local/opt/Python/lib/python2.2/site-packages/Webware/Cheetah/Compiler.py",
  > line 102, in genCacheInfoFromArgList
  >     val = self.genTimeInterval(val)
  >   File
  > "/local/opt/Python/lib/python2.2/site-packages/Webware/Cheetah/Compiler.py",
  > line 75, in genTimeInterval
  >     interval = float(timeString)*60
  > ValueError: invalid literal for float(): .5m' id'cache1
  > 
  > 
  > Running under pdb shows that Parser.getDefArgList() returned:
  > "30m' id'cache1" .


- Delete whitespace before comments.  If the rest of the line consists
  of only non-outputting directives and whitespace, delete the line from the
  output.  The only outputting directives I see are #echo, #block and
  #include. -- MO

- 'python setup.py uninstall'.  This may require hacking an uninstall feature
  into distutils.

- 'errorCatcher None' to stop catching errors in the middle of a template.

- #del is the only statement that's missing, and there seems to be no other way
  to do it.  #silent wants an expression, not a statement.  I'm mainly thinking
  about deleting keys from local dictionaries -- delattr() doesn't do this --
  but there's no reason it shouldn't work on local subscripts, attributes and
  variables too.  Leave open the possibility for '#del global' (opposite of
  '#set global') in the future if it's needed, and 
  '#del searchList $var["key"]' too.  I don't know about '#del searchList $var':
  that could be hard to implement, but maybe somebody will want it someday.


Rewrite the caching framework
=============================
- add #cache varyBy= (tied to Tavis' proposed caching framework for Webware)

- #cache test= with a one-variable test produces invalid Python (an empty
  if-block).  Example in Cheetah Developers' Guide, section
  "#cache with test: expression and method conditions".

- #cache id= seems to be ignoring the ID and generating a random numeric
  ID instead.  Is it working?  Do cache IDs have to be numeric?

- Other ideas in Tavis' head.


Cheetah command revamp
===============================================================================
- Usage: cheetah COMMAND ARGUMENTS
- Commands:
     cheetah --help | -h
     cheetah --version
     cheetah compile | c           # .tmpl -> .py
     cheetah fill | f              # .tmpl -> .html       (Not implemented yet)
     cheetah cgi                   # .tmpl -> CGI script  (Not implemented yet)

- Delay implementation of 'cheetah cgi' until spec is more precise.  (In
  the meantime, you can use 'cheetah compile' and put 
  	Content-type: text/html
  and a blank line at the top of the template definition.)

- Options common to 'compile', 'fill' and 'cgi':
    -i EXT                         # input file extension  (-i '' for no ext)
    -o EXT                         # output file extension (-o '' for no ext)
    -R                             # recurse subdirectories
    -                              # (as input filename) input from stdin
    -p                             # output to stdout

- Options for 'fill' (and .py template modules):
    --env                          # Push environment onto searchList.
    --pickle=FILE                  # Unpickle FILE and push onto searchList.
                                   # (--pickle=-  => unpickle from stdin)

- Remove options:
    cheetah-compile -w             # Same as 'cheetah fill' but less powerful.
    cheetah -c                     # 'cheetah c' is easier to type.
    -p (pickle)                    # Conflicts with -p (to stdout)

- Input extension, unless overridden by -i, is ".tmpl".  If an input file is 
  specified but does not exist, try adding this extension.  When recursing,
  consider only files with this extension.

- Output extension, unless overridden by -o, is ".py" for 'cheetah compile'
  and 'cheetah cgi', and ".html" for 'cheetah fill'.

- Program will examine its own name ( os.path.basename(sys.argv[0]) ), and if
  it looks like "cheetah-WORD", use WORD as the command instead of sys.argv[1] .
  Then cheetah-compile can be a symlink or copy of this, and people can create
  cheetah-fill etc if desired.


#wrapper
===============================================================================
Goal: make it more convenient to use templates in programs by providing a
wrapper function in the .py template module.  The function specifies how
many arguments it needs and creates a searchList based on those arguments.
New directives: #wrapper, ##doc-wrapper:, #*doc-wrapper: ... *#
Usage: #wrapper $func($arg1, $arg2="default", ...)
This example creates the following function in the .py template module:
	def func(arg1, arg2="default", ...):
		"""Function docstring."""
		sl = {'arg1': arg1, 'arg2': arg2, ...}
		t = TheTemplate(searchList=[sl])
		return str(t)
The doc-wrapper directives append the text to the #wrapper's docstring.
	Finally, make this function accessible directly from the shell.
If there are any non-option arguments on the command line, call the function
instead of filling the template the normal way.  
	There should be only one #wrapper per template.  We could allow 
multiple if there's a demand, but #wrapper is mainly intended for templates
that want to be called one particular way.  If we do have multiple functions,
we'd need a rule that doc-wrapper's apply to the previous function, and the
shell command line would have to specify the function name, either as
        template.py -w func "arg1" "arg2"
or      template.py func "arg1" "arg2"
In the latter case, the function name would always have to be specified,
which I think is undesired.
	Should it be called #wrapper, #access, #entry, etc?
	



Test Suite
================================================================================
- test cases for the SkeletonPage framework
- add cases that test the cheetah-compile script
- add cases that test the integration with WebKit.  Since these must be called
  from a running WebKit server, make a servlet that runs the tests and outputs
  diagnostics to the browser.

Website
================================================================================
- automate the documentation update 
- See if we can get WebKit working on Sourceforge...

Examples
================================================================================
- create some non-html code generation examples
  - SQL
  - LaTeX
  - form email
- Template definitions in a database.  .py template modules in a 
  database?  Caching template classes and/or instances extracted from
  a database.
- Pickled templates?

