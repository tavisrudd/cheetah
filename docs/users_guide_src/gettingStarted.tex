\section{Getting Started}
\label{gettingStarted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Requirements}
\label{gettingStarted.requirements}

Cheetah requires Python release 2.0 or greater and should run on any
operating system that Python 2.0 runs on.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installation}
\label{gettingStarted.install}

To install Cheetah for system-wide use:
\begin{enumerate}
\item Login as a user with privileges to install Python packages.  On POSIX
     systems (AIX, Solaris, Linux, IRIX, etc.), the command is normally
     'su root'.  On non-POSIX systems such as Windows NT, login as an 
     administrator.

\item Run \code{python setup.py install} at the command prompt.

\item The setup program will install the program {\bf cheetah-compile} to the
     "bin/" directory of your Python distribution.  If that directory is not
     in your users' normal path, copy or symlink it to a directory that is in
     their path.  
\end{enumerate}

%% @@MO: What about cheetah-compile on non-POSIX systems? 

We do not currently have instructions for non-privileged users installing
Cheetah in their home directory.  It's basically a matter of copying the 'src'
subdirectory to a location on your PYTHONPATH and renaming it as 'Cheetah'.
However, the C module '\_namemapper.c' must be compiled, and the script
'cheetah-compile' must be generated and placed in '~/bin'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testing your installation}
\label{gettingStarted.test}

You can run the test suite to insure that your installation is correct by
following these steps:
\begin{enumerate}
\item CD into the directory ./src/Tests   
\item type: \code{python Test.py} 
\end{enumerate}

If the tests pass, start Python in interactive mode and try the example in the
Introduction section of this guide.

If any of the tests fail please send a message to the email list with a copy of
the test output and the following details about your installation:

\begin{enumerate}
\item your version of Cheetah
\item your version of Python
\item your operating system
\item whether you have changed anything in the Cheetah installation
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quickstart tutorial}
\label{gettingStarted.tutorial}

This tutorial briefly introduces the basic usage of Cheetah.  See the
following chapters for more detailed explanations.  

{\bf This tutorial will be fleshed out further at later date.} 

The core of Cheetah is the \code{Template} class in the \code{Cheetah.Template}
module. The following example shows how to use the \code{Template} class from an
interactive Python session. Lines prefixed with \code{>>>} and \code{...} are
user input.  The remaining lines are Python output.

\begin{verbatim}
>>> from Cheetah.Template import Template
>>> templateDef = """
... <HTML>
... <HEAD><TITLE>$title</TITLE></HEAD>
... <BODY>
... $contents
... ## this is a single-line Cheetah comment and won't appear in the output
... #* This is a multi-line comment
...    blah, blah, blah 
... *#
... </BODY>
... </HTML>"""
>>> nameSpace = {'title': 'Hello World Example', 'contents': 'Hello World!'}
>>> templateObj = Template(templateDef, searchList=[nameSpace])
>>> print templateObj
 
<HTML>
<HEAD><TITLE>Hello World Example</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
>>> print templateObj    # print it as many times as you want
      [ ... identical output not shown ... ]
>>> nameSpace['title'] = 'Example #2'
>>> nameSpace['contents'] = 'Hiya Planet Earth!'
>>> print templateObj   # Now with different plug-in values.
      [ ... the output it the same as the first example above ... ]
<HTML>
<HEAD><TITLE>Example #2</TITLE></HEAD>
<BODY>
Hiya Planet Earth!
</BODY>
</HTML>

\end{verbatim}

Since Cheetah is extremely flexible, you can achieve the same result this
way:  

\begin{verbatim}
>>> templateObj2 = Template(templateDef)
>>> templateObj2.title = 'Hello World Example!'
>>> templateObj2.contents = 'Hello World'
>>> print templateObj2
      [ ... the output is the same as the first example above ... ]
>>> templateObj2.title = 'Example #2'
>>> templateObj2.contents = 'Hello World!'
>>> print templateObj2
     [ ... same as Example #2 above ... ]
\end{verbatim}

Or this way:

\begin{verbatim}
>>> class Template3(Template):
>>>     title = 'Hello World Example!'
>>>     contents = 'Hello World!'
>>> templateObj3 = Template3(templateDef)
>>> print templateObj3
     [ ... you get the picture ... ]
\end{verbatim}

The template definition can also come from a file instead of a string,
as we will see in section \ref{howWorks.constructing}.

The above is all fine for short templates, but for long templates or
for an application that depends on many templates in a hierarchy, it's
easier to store the templates in separate *.tmpl files and use the
{\bf cheetah-compile} program to convert them into Python classes in
their own modules.  This will be covered in section ??.  

As an appetizer, we'll just briefly mention that you can store constant values
{\em inside} the template definition, and they will be converted to attributes
in the generated class.  You can also create methods the same way.
You can even use inheritance to arrange your templates in a hierarchy,
with more specific templates overriding certain parts of more general
templates (e.g., a "page" template overriding a sidebar in a "section"
template).

% Local Variables:
% TeX-master: "users_guide"
% End:      

