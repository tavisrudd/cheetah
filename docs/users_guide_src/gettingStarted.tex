\section{Getting Started}
\label{gettingStarted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Requirements}
\label{gettingStarted.requirements}

Cheetah requires Python release 2.0 or greater and should run on any
operating system that Python 2.0 runs on.  It has been tested on
Python 2.0, 2.1 and 2.2b1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installation}
\label{gettingStarted.install}

To install Cheetah to your system-wide Python library:
\begin{enumerate}
\item Login as a user with privileges to install system-wide Python packages.
     On POSIX systems (AIX, Solaris, Linux, IRIX, etc.), the command is normally
     'su root'.  On non-POSIX systems such as Windows NT, login as an
     administrator.

\item Run \code{python setup.py install} at the command prompt.

\item The setup program will install the wrapper script {\bf cheetah} to the
     "/usr/bin" or something like that.
\end{enumerate}

%% @@MO: What about cheetah-compile on non-POSIX systems? 

To install Cheetah to an alternate location use the options to setup.py's
\code{install} command:
\begin{verbatim}
    python setup.py install --home /home/tavis 
and
    python setup.py install --install-lib /home/tavis/lib/python
both install to /home/tavis/lib/python/Cheetah
\end{verbatim}

Cheetah's installation is managed by Python's Distribution Utilities
('distutils').  There are many options for customization.  Type \code{``python
  setup.py help''} for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The 'cheetah' command}
\label{gettingStarted.cheetah}

Cheetah comes with a utility \code{cheetah} that provides a command-line
interface to various housekeeping tasks.  The command's first argument is
the name of the task.  The following tasks are currently supported:

\begin{verbatim}
cheetah --help|-h            
          - Print this usage information
cheetah compile|-c [compiler options]
          - Run Cheetah's compiler ('cheetah compile --help' for more)
cheetah test|-t [test options]
          - Run Cheetah's test suite ('cheetah test --help' for more)
cheetah --version|-v
          - Print Cheetah's version number
\end{verbatim}

The test suite is described in the next section.  The compiler will be
described in section \ref{howItWorks.cheetah-compile}.

For backward compatibility, the separate \code{cheetah-compile} program
does the same thing as \code{cheetah compile}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testing your installation}
\label{gettingStarted.test}

You can run the test suite to insure that your installation is correct by
following these steps:
\begin{enumerate}
\item install Cheetah as explained above
\item type: \code{cheetah test} 
\end{enumerate}

If the tests pass, start Python in interactive mode and try the example in the
Introduction section of this guide.

If any of the tests fail please send a message to the email list with a copy of
the test output and the following details about your installation:

\begin{enumerate}
\item your version of Cheetah
\item your version of Python
\item your operating system
\item whether you have changed anything in the Cheetah installation
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quickstart tutorial}
\label{gettingStarted.tutorial}

This tutorial briefly introduces the basic usage of Cheetah.  See the
following chapters for more detailed explanations.  

{\bf This tutorial will be fleshed out further at later date.} 

The core of Cheetah is the \code{Template} class in the \code{Cheetah.Template}
module. The following example shows how to use the \code{Template} class from an
interactive Python session. Lines prefixed with \code{>>>} and \code{...} are
user input.  The remaining lines are Python output.

\begin{verbatim}
>>> from Cheetah.Template import Template
>>> templateDef = """
... <HTML>
... <HEAD><TITLE>$title</TITLE></HEAD>
... <BODY>
... $contents
... ## this is a single-line Cheetah comment and won't appear in the output
... #* This is a multi-line comment
...    blah, blah, blah 
... *#
... </BODY>
... </HTML>"""
>>> nameSpace = {'title': 'Hello World Example', 'contents': 'Hello World!'}
>>> templateObj = Template(templateDef, searchList=[nameSpace])
>>> print templateObj
 
<HTML>
<HEAD><TITLE>Hello World Example</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
>>> print templateObj    # print it as many times as you want
      [ ... identical output not shown ... ]
>>> nameSpace['title'] = 'Example #2'
>>> nameSpace['contents'] = 'Hiya Planet Earth!'
>>> print templateObj   # Now with different plug-in values.
      [ ... the output it the same as the first example above ... ]
<HTML>
<HEAD><TITLE>Example #2</TITLE></HEAD>
<BODY>
Hiya Planet Earth!
</BODY>
</HTML>

\end{verbatim}

Since Cheetah is extremely flexible, you can achieve the same result this
way:  

\begin{verbatim}
>>> templateObj2 = Template(templateDef)
>>> templateObj2.title = 'Hello World Example!'
>>> templateObj2.contents = 'Hello World'
>>> print templateObj2
      [ ... the output is the same as the first example above ... ]
>>> templateObj2.title = 'Example #2'
>>> templateObj2.contents = 'Hello World!'
>>> print templateObj2
     [ ... same as Example #2 above ... ]
\end{verbatim}

Or this way:

\begin{verbatim}
>>> class Template3(Template):
>>>     title = 'Hello World Example!'
>>>     contents = 'Hello World!'
>>> templateObj3 = Template3(templateDef)
>>> print templateObj3
     [ ... you get the picture ... ]
\end{verbatim}

The template definition can also come from a file instead of a string,
as we will see in section \ref{howWorks.constructing}.

The above is all fine for short templates, but for long templates or
for an application that depends on many templates in a hierarchy, it's
easier to store the templates in separate *.tmpl files and use the
{\bf cheetah compile} program to convert them into Python classes in
their own modules.  This will be covered in section ??.  

As an appetizer, we'll just briefly mention that you can store constant values
{\em inside} the template definition, and they will be converted to attributes
in the generated class.  You can also create methods the same way.
You can even use inheritance to arrange your templates in a hierarchy,
with more specific templates overriding certain parts of more general
templates (e.g., a "page" template overriding a sidebar in a "section"
template).

For the minimalists out there, here's a template definition,
instantiation and filling all in Python statement:

\begin{verbatim}
>>> print Template("Templates are pretty useless without placeholders.")
Templates are pretty useless without placeholders.
\end{verbatim}


% Local Variables:
% TeX-master: "users_guide"
% End:      

