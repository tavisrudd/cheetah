\section{Language Overview}
\label{language}


Cheetah's basic syntax was inspired by the Java-based template engines Velocity
and WebMacro. It has two types of tags: {\bf placeholders} and {\bf directives}.
Both types are case-sensitive.  

Placeholder tags begin with a dollar sign (\code{\$varName}) and are similar to
data fields in a form letter or the \code{\%(key)s} fields Python's \code{\%}
operator uses. When a template is processed, placeholders are replaced with the
value they refer to.

Directive tags begin with a hash character (\#) and are used for comments,
loops, conditional blocks, includes, and all other advanced features. Cheetah
uses a Python-like syntax inside directive tags and understands any valid
Python expression.  Some of the main differences from pure Python syntax are
that variable names are prefaced with a dollar sign (\$), that colons (:) are
not used to mark the beginning of a code block, and indentation is not
significant.  See section \ref{language.namemapper} below for details of
another important difference. Most of the directive tags listed below are
direct mirrors of Python statements.

Cheetah does not use HTML/XML-style tags like some other template languages for
the following reasons:
\begin{itemize}
\item Cheetah is not limited to HTML
\item HTML-style tags are hard to distinguish from real HTML tags
\item HTML-style tags are not visible in rendered HTML when something goes wrong
\item HTML-style tags often lead to invalid HTML, as with
     \code{<img src=''<template-directive>''>}
\item Cheetah tags are less verbose and easier to understand than
     HTML-style tags
\item HTML-style tags aren't compatible with most WYSIWYG editors
\end{itemize}

Besides being much more compact, Cheetah also has some advantages over
languages that put information inside the HTML tags, such as Zope Page
Templates or PHP:

\begin{itemize}
\item HTML or XML-bound languages do not work well with other languages.
\item While ZPT-like syntaxes work well in many ways with WYSIWYG HTML editors,
     they also give up a significant advantage of those editors -- concrete
     editing of the document.  When logic is hidden away in (largely
     inaccessible) tags it is hard to understand a page simply by viewing it,
     and it is hard to confirm or modify that logic.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Language Constructs -- Summary}
\label{language.constructs}

\begin{enumerate}
\item Comments and documentation strings
     \begin{enumerate}
     \item \code{\#\# single line}
     \item \code{\#* multi line *\#}
     \end{enumerate}

\item Generation, caching and filtering of output
     \begin{enumerate}
     \item plain text
     \item output from simple expressions: \code{\$placeholders}
     \item output from more complex expressions: \code{\#echo} \ldots
     \item silencing output from expressions: \code{\#silent} \ldots
     \item gobble the EOL: \code{\#slurp}
     \item parsed file includes: \code{\#include} \ldots
     \item raw file includes: \code{\#include raw} \ldots
     \item verbatim output of Cheetah code: \code{\#raw} \ldots \code{\#end raw}
     \item cached placeholders: \code{\$*var}, \code{\$*<interval>*var}
     \item cached regions: \code{\#cache} \ldots \code{\#cache}
     \item set the output filter: \code{\#filter} \ldots
     \end{enumerate}
          
\item Importing Python modules and objects: \code{\#import} \ldots,
     \code{\#from} \ldots

\item Inheritance 
     \begin{enumerate}
     \item set the base classes to inherit from: \code{\#extends}
     \item set the name of the main method to implement: \code{\#implements} \ldots
     \end{enumerate}

\item Compile-time declaration
     \begin{enumerate}
     \item define class attributes: \code{\#attr} \ldots
     \item define class methods: \code{\#def} \ldots \code{\#end def}
     \item \code{\#block} \ldots \code{\#end block} provides a simplified
          interface to \code{\#def} \ldots \code{\#end def}
     \item define class 'settings': \code{\#settings} \ldots \code{\#end settings}
     \end{enumerate}

\item Run-time assignment
     \begin{enumerate}
     \item local vars: \code{\#set} \ldots
     \item global vars: \code{\#set global} \ldots
     \end{enumerate}

\item Flow control
     \begin{enumerate}
     \item \code{\#if} \ldots \code{\#else} \ldots \code{\#else if} (aka
          \code{\#elif}) \ldots \code{\#end if}
     \item \code{\#unless} \ldots \code{\#end unless}
     \item \code{\#for} \ldots \code{\#end for}
     \item \code{\#repeat} \ldots \code{\#end repeat}
     \item \code{\#while} \ldots \code{\#end while}
     \item \code{\#break}
     \item \code{\#continue}
     \item \code{\#pass}
     \item \code{\#stop}
     \end{enumerate}

\item error/exception handling
     \begin{enumerate}
     \item \code{\#assert}
     \item \code{\#raise}
     \item \code{\#try} \ldots \code{\#except} \ldots \code{\#else} \ldots
          \code{\#end try} and  \code{\#finally}
     \item \code{\#errorCatcher} \ldots sets a default exception catcher/handler for
          exceptions raised by \$placeholder calls.
     \end{enumerate}

\item Instructions to the parser/compiler
     \begin{enumerate}
     \item \code{\#breakpoint}
     \item \code{\#compiler-settings} \ldots \code{\#end compiler-settings}
     \end{enumerate}
\end{enumerate}

Cheetah also supports two ASP (Active Server Pages) style tags as escapes to
pure Python code. These are not part of Cheetah's core language, but are
included to facilitate migration from ASP-style markup languages to Cheetah.
These tags may not be used inside other Cheetah tags.
\begin{enumerate}
\item evalute expression and print the output: \code{<\%=} \ldots \code{\%>} 
\item execute code and discard output: \code{<\%} \ldots \code{\%>}
\end{enumerate}

%% @@MO: TODO: reconcile the order of this summary with the order in the
%% detail sections.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Placeholder Syntax Rules}
\label{language.placeholdersRules}

\begin{itemize} 
     
\item Placeholder names consist of one or more identifiers separated by periods.
     Each identifier follows the same rules as a Python variable name or
     attribute name: it must start with a letter or an underscore, and the
     subsequent characters must be letters, numbers or underscores.  An
     identifier may be followed by argument sets enclosed in ``()'' and/or
     key/subscript arguments in ``[]''.

\item Identifiers are case-sensitive. \code{\$var} does not equal \code{\$Var}
     or \code{\$vAr} or \code{\$VAR}.     
     
\item String literals inside argument sets must be quoted, just like in Python.
     All Python quoting styles are allowed.
     
\item All variable names inside argument sets should be prefixed with a \$.
     Use \$func(\$var) instead of \$func(var).  Python's builtin functions also
     follow this rule.

\item All argument names inside argument sets should be prefixed with a \$.
     Use \$func(\$arg=1234) instead of \$func(arg=1234).  This rule also applies
     for *arg and **kw forms: \$func(\$*args) instead of \$func(*args).
    
\item Trailing periods are ignored.  Cheetah will recognize that the placeholder
     name in \code{\$varName.} is \code{varName} and the period will be left
     alone in the template output.
     
\item Placeholders can also be written in the form \code{\$\{placeholderName\}}
     and \code{\$(placeholderName)}.  This is useful for cases where there is no
     whitespace between the placeholder and surrounding text
     (\code{surrounding\$\{embeddedVar\}text}).  The form with braces is called
     the {\em long placeholder syntax}; the form without braces is called, you
     guessed it, the {\em short placeholder syntax}.

\item The syntax \code{\$\{placeholderName, arg1="val1"\}} passes arguments to
     the output filter (see \code{\#filter}, section \ref{output.filter}.
     The braces and comma are required in this case.  Note that you don't need
     the \code{\$} prefix in this case since filter arguments are not regular
     method arguments, and omiting the \code{\$} reminds you of this fact.
     However, you may use \code{\$} anyway if you wish.

\item The special Python name \code{None} does not require a
     \code{\$} prefix.  (This applies only in expressions; e.g., as a method
     argument.  The word None in surrounding text is treated as regular text.)
     But you can use \code{\$None} if you want.

\item There is one place you {\em must} omit the \code{\$} prefix: intermediate
     variables in Python list comprehensions.  This is a limitation of
     Cheetah's parser, but it also makes sense.  These are temporary variables
     local to the list comprehension,  and not any of Cheetah's business.  For
     example:
\begin{verbatim}
#set $theRange = [x ** 2 for x in $range(10)]
\end{verbatim}
     \code{\$theRange} is a regular \code{\#set} variable.  \code{\$range} is a
     Python built-in function.  But \code{x} is a scratch variable internal to
     the list comprehension: if you type \code{\$x}, Cheetah will miscompile it.
\item Cheetah ignores all dollar signs (\code{\$}) that are not followed by a
     letter or an underscore.  Cheetah also ignores any placeholder escaped by a
     backslash (\code{$\backslash$\$placeholderName}).

\end{itemize} 

The following are valid \$placeholders:
\begin{verbatim}
$a $_ $var $_var $var1 $_1var $var2_ $dict.key $list[3]
$object.method $object.method() $object.method
$nest($nest($var))
\end{verbatim}

These are not \$placeholders:
\begin{verbatim}
$@var $^var $15.50
\end{verbatim}

You can use compiler settings to change the placeholder delimeters if
\code{\$}, \code{\{} and \code{\}} are not suitable.  This will be documented
in the future.  None of the examples in this Guide use this feature.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Directive Syntax Rules}
\label{language.directives}

Directives tags are used for all functionality that cannot be handled with
simple placeholders. Some directives consist of a single tag while others
consist of a pair of {\bf start} and {\bf end} tags that surround a chunk of
text.  End tags are written in the form \code{\#end [directive-name]}.
Directives are case-sensitive.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Escaping directives}
\label{language.directives.escaping}

Directives can be escaped by placing a backslash before them.  Escaped
directives will be printed verbatim.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Directive closures and whitespace handling}
\label{language.directives.closures}
Directive tags can be closed explicitly with \code{\#}, or implicitly with the
end of the line if you're feeling lazy.

\begin{verbatim}
#block testBlock #
Text in the body of the
block directive
#end block testBlock #
\end{verbatim}
is identical to:
\begin{verbatim}
#block testBlock
Text in the body of the
block directive
#end block testBlock
\end{verbatim}

When a directive tag is closed explicitly it can be followed with other text on
the same line:

\begin{verbatim}
bah, bah, #if $sheep.color == 'black'# black#end if # sheep.
\end{verbatim}

When a directive tag is closed implicitly with the end of the line, all trailing
whitespace is gobbled, including the newline character:
\begin{verbatim}
"""
foo #set $x = 2 
bar
"""
outputs 
"""
foo bar
"""

while 
"""
foo #set $x = 2 #
bar
"""
outputs 
"""
foo 
bar
"""
\end{verbatim}

When a directive tag is closed implicitly AND there is no other text on the
line, the ENTIRE line will be gobbled up including any preceeding whitespace:
\begin{verbatim}
"""
foo 
   #set $x = 2 
bar
"""
outputs 
"""
foo
bar
"""

while 
"""
foo 
 - #set $x = 2
bar
"""
outputs 
"""
foo 
 - bar
"""
\end{verbatim}

The \code{\#slurp} directive (section
\ref{directives.slurp}) also gobbles up whitespace.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Variables in directives}
\label{language.directives.variables}

Variable names used inside a directive tag should be prefaced by \$, as in this
example:

\begin{verbatim}
#for $clientName, $address in $clients.addresses
$clientName: $address
#end for
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{NameMapper Syntax}
\label{language.namemapper}

One of our core aims for Cheetah was to make it easy for non-programmers to
use. Therefore, Cheetah uses a simplified syntax for mapping variable
names in Cheetah to values in Python. It's known as the{\bf NameMapper syntax}
and allows for non-programmers to use Cheetah without knowing (a)
what the difference is between an object and a dictionary, (b) what functions
and methods are, and (c) what 'self' is. A side benefit is that NameMapper
syntax insulates the code in Cheetah templates from changes in the implementation
of the Python data structures behind them.

NameMapper syntax is used for all variables in Cheetah placeholders and
directives. If desired, it can be turned off via the \code{Template} class'
\code{'useNameMapper'} compiler setting.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Example}
\label{language.namemapper.example}

Consider this scenario:

You've been hired as a consultant to design and implement a customer information
system for your client. The class you create has a 'customers' method that
returns a dictionary of all the customer objects.  Each customer object has an
'address' method that returns the a dictionary with information about the
customer's address.

The designers working for your client want to use information from your system
on the client's website --AND-- they want to maintain the display code
themselves.

Using PSP, the display code for the website would look something like this,
assuming your servlet is a subclass of your customer class:


\begin{verbatim}
  <%= self.customer()[ID].address()['city'] %>   (42 chars)
\end{verbatim}

With Cheetah's NameMapper syntax, you can use any of the following:

\begin{verbatim}
   $self.customers()[$ID].address()['city']       (39 chars)
   --OR--                                         
   $customers()[$ID].address()['city']           
   --OR--                                         
   $customers()[$ID].address().city              
   --OR--                                         
   $customers()[$ID].address.city                
   --OR--                                         
   $customers()[$ID].address.city
   --OR--
   $customers[$ID].address.city                   (27 chars)                     
\end{verbatim}   

Which of these would you prefer to explain to the designers, who have no
programming experience?  The last form is 15 characters shorter than the PSP
version and -- conceptually -- far more accessible. With PHP or ASP, the
code would be even messier than with PSP.

This is a rather extreme example and, of course, you could also just implement
\code{\$customer(\$ID).city} and obey the Law of Demeter (search Google for more
on that).  But good object orientated design isn't the point of this example.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Dictionary Access}
\label{language.namemapper.dict}

NameMapper syntax allows access to dictionary items using the same dotted
notation used to access object attributes in Python.  This aspect of NameMapper
syntax is known as 'Unified Dotted Notation'.
For example, with Cheetah it is possible to write:
\begin{verbatim}
   $customers()['kerr'].address()  --OR--  $customers().kerr.address()
\end{verbatim}
where the second form is in NameMapper syntax.

This works only with dictionary keys that are also valid Python identifiers.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Autocalling}
\label{language.namemapper.autocalling}

Cheetah automatically detects functions and methods in Cheetah \$variables and calls
them if the parentheses have been left off.  

For example if 'a' is an object, 'b' is a method
\begin{verbatim}
  $a.b
\end{verbatim}

is equivalent to

\begin{verbatim}
  $a.b()
\end{verbatim}

If b returns a dictionary, then following variations are possible
\begin{verbatim}
  $a.b.c  --OR--  $a.b().c  --OR--  $a.b()['c']
\end{verbatim}
where 'c' is a key in the dictionary that a.b() returns.

Further notes:
\begin{itemize}
\item Cheetah autocalls the function or method without any arguments.  Thus
autocalling can be used only with functions or methods that either have no
arguments or have default values for all arguments.

\item Cheetah autocalls only functions and methods.  Classes and other callable
objects are not autocalled.  

\item Autocalling can be disabled via Cheetah's 'useAutocalling' compiler
setting.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Underscored attributes}
\label{language.namemapper.underscore}

If a 'name' in Cheetah doesn't correspond to a valid object attribute name in
Python, but there is an attribute in the form '\_name', NameMapper will return
the underscored attribute.

This removes the need to change all placeholders like \code{\$clients.list} to
\code{\$clients.\_list} when the 'list' attribute of 'clients' is changed to or
from an underscored attribute.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Namespace cascading and the searchList}
\label{language.namemapper.searchList}

When Cheetah maps variable name in a template to a Python value, it searches
through a list of namespaces known as the Template object's \code{searchList}.
By default, the only namespace in the \code{searchList} is the template object
itself. This means that its attributes or methods can be accessed in templates
via \code{\$placeholders} without needing to include 'self' in the reference as
you do in Python. 

(Note: the values looked up are called ``namespace values'' or 
``placeholder values'' interchangeably.)

The \code{searchList} can be used to override or supplement the variables in the
template object's namespace without needing to create a subclass.  When Cheetah
fills in \code{\$myVar} it searches sequentially through the searchList until it
finds a value for \code{myVar}.  Thus, if three namespaces are loaded and two of
them contain a value for \code{\$myVar}, the value for \code{myVar} from the
namespace that is closest to the start of the searchList will be returned.

If you add a Python object to the searchList, its attributes and methods will
be accessible as \$placeholder names.  If the object is a dictionary, its keys
are accessible as if they were attributes.  For example, \code{myObject}
contains \code{myAttrib} and \code{myMethod}.  If \code{myObject} is added to
the searchList, \code{\$myAttrib} and \code{\$myMethod} can be used as
placeholder names.

The\code{\_\_init\_\_} method of the \code{Template} class, and the subclasses
generated by the Cheetah compiler, accept a list of namespaces that will be
added to the start of the \code{searchList}.  Extra namespaces can be added to
the end of the searchList at at any time using the
\code{Template.addToSearchList()} method.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Local variables}
\label{language.namemapper.localVariables}

The following names are accessible by \code{\$placeholders}, even though they
are not in the searchList:  

\begin{enumerate}
\item \code{\#set} variables and \code{\#set global} variables.
\item \code{\#for} loop counters.
\item the template object's \code{self} (i.e., \code{\$self.attrib1}).
\item Python's built-in functions and objects (everything in module
     \code{\_\_builtin\_\_}).
\end{enumerate}

These are in fact local variables in the generated class method.  The compiler
can tell by context which \code{\$placeholders} should be looked up in the
searchList and which are local variables, so it generates the appropriate
Python lookup code for either case.  The compiler can also tell when to do
NameMapper lookup on a local variable; e.g.:
\begin{verbatim}
#for $client in $clients 
$client.name
#end for
\end{verbatim}
The compiler knows that \code{\$client} is a local variable because it's a
\code{\#for} loop counter.  The compiler also knows it has to do NameMapper
lookup on the \code{.name} suffix in case it's a dictionary key or 
autocallable.  So the compiler generates the appropriate Python code.

If you want to make absolutely sure that you are accessing an attribute or
method of the template object, include 'self' in the reference:
\code{\$self.attrib1} instead of \code{\$attrib1}.  (With \code{self.}, it's
a local variable lookup.  Without \code{self.}, Cheetah consults the 
searchList.  Since \code{self} is the {\em last} element in the searchList,
any other 'attrib1' in the searchList will override that one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Missing values}
\label{language.namemapper.missing}

If NameMapper can not find a Python value for a Cheetah variable name, it will
raise the NameMapper.NotFound exception.  You can use the \code{\#errorCatcher}
directive (section \ref{errorHandling.errorCatcher}) or {\bf errorCatcher }
constructor argument (section \ref{howWorks.constructing}) to specify an
alternate behaviour.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variable tips}
\label{language.namemapper.tips}

%% @@TR: These should be put somewhere else.  This chapter is supposed to
%% provide only a summary of the language.

{\bf Tips for any template}

Here's how to do certain important lookups that may not be obvious.
Forms beginning with \code{\$} are placeholders.  Forms beginning with
\code{self.} do the equivalent from Python, assuming you are in a method in
the template object (or inherited by the template object).

To verify whether a variable exists in the searchList:
\begin{verbatim}
$varExists('theVariable')
self.varExists('theVariable')
\end{verbatim}
This is useful in \code{\#if} or \code{\#unless} constructs to avoid a
\code{\#NameMapper.NotFound} error if the variable doesn't exist.  For instance,
a CGI GET parameter that is normally supplied but in this case the user typed
the URL by hand and forgot the parameter (or didn't know about it).

To look up a variable in the searchList from a Python method:
\begin{verbatim}
self.getVar('theVariable')
self.getVar('theVariable', None)
self.getVar('theVariable', myDefault)
\end{verbatim}
This is the equivalent to \code{\$theVariable} in the template.  \code{getVar}
returns the second argument (\code{None} or \code{myDefault} if the variable is
missing; or, if there is no second argument, it raises raises
\code{NameMapper.NotFound}.

To do a ``safe'' placeholder lookup that returns a default value if the
variable is missing:
\begin{verbatim}
$getVar('theVariable', None)
$getVar('theVariable', $myDefault)
\end{verbatim}

To get an environmental variable, put \code{os.environ} as one of the
elements in the searchList.  Or read the envvar in Python code and set a
placeholder variable for it.

Remember that variables found earlier in the searchList override same-name variables
located in a later searchList object.  Be careful when adding objects containing other
variables besides the ones you want (e.g., \code{os.environ}, CGI parameters).
The "other" variables may override variables your application depends on, leading to
hard-to-find bugs.  Also, users can inadvertantly or maliciously set an environmental
variable or CGI parameter you didn't expect, screwing up your program.  To
avoid all this, know what your namespaces contain, and place the namespaces you
have the most control over first.  For namespaces that could contain
user-supplied "other" variables, don't put the namespace itself in the
searchList; instead, copy the needed variables into your own "safe" namespace.

{\bf Tips for templates that are Webware servlets}

[Note: these are currenty untested.]

To look up a CGI GET or POST parameter (with POST overriding):
\begin{verbatim}
$request.field('myField')        ## Using autocalling only.
$request().field('myField')      ## Using neither, boring.
self.request().field('myField')
\end{verbatim}
These will fail if Webware is not available, because \code{\$request}
(aka \code{self.request()} will be \code{None} rather than a Webware
\code{WebKit.Request} object.  If you plan to read a lot of CGI parameters,
you may want to put the \code{.field} method in a local variable for
convenience:
\begin{verbatim}
#set $field = $request.field
$field.myField
$field('myField')
\end{verbatim}
But remember to do complicated calculations in Python, and assign the results
to simple variables in the searchList for display.  These \code{\$request}
forms are useful only for occasions where you just need one or two simple
request items that going to Python for would be overkill.

To get a cookie or session parameter, subsitute ``cookie'' or ``session'' for
``field'' above.  To get a dictionary of all CGI parameters, substitute
``fields'' (ditto for ``cookies'').  To verify a field exists,
substitute ``hasField'' (ditto for ``hasCookie'').  

Other useful request goodies:
\begin{verbatim}
## Defined in WebKit.Request
$request.time              ## Time this request began in Unix ticks.
$request.timeStamp         ## Time in human-readable format ('asctime' format).
## Defined in WebKit.HTTPRequest
$request.hasField.myField  ## Is a CGI parameter defined?
$request.fields            ## Dictionary of all CGI parameters.
$request.cookie.myCookie   ## A cookie parameter (also .hasCookie, .cookies).
$request.value.myValue     ## A field or cookie variable (field overrides)
                           ## (also .hasValue).
$request.session.mySessionVar  # A session variable.
$request.extraURLPath      ## URL path components to right of servlet, if any.
$request.serverDictionary  ## Dict of environmental vars from web server.
$request.remoteUser        ## Authenticated username.  HTTPRequest.py source
                           ## suggests this is broken and always returns None.
$request.remoteAddress  ## User's IP address (string).
$request.remoteName     ## User's domain name, or IP address if none.
$request.urlPath        ## URI of this servlet.
$request.urlPathDir     ## URI of the directory containing this servlet.
$request.serverSidePath ## Absolute path of this servlet on local filesystem.
$request.serverURL      ## URL of this servlet, without "http://" prefix,
                        ## extra path info or query string.
$request.serverURLDir   ## URL of this servlet's directory, without "http://".
$log("message")         ## Put a message in the Webware server log.  (If you
                        ## define your own 'log' variable, it will override
                        ## this; use $self.log("message") in that case.
\end{verbatim}

% @@ MO: If getVar() is called from Python, does errorCatcher apply?

% @@ MO: Move all Webware variables to webware.tex?

% Local Variables:
% TeX-master: "users_guide"
% End:      

% # vim: expandtab
