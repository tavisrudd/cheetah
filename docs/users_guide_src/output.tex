\section{Generating, Caching and Filtering Output}
\label{output}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output From Simple Expressions: Placeholders}
\label{output.placeholders}

Placeholders are like 'primaries' in Python (see section 5.3 of Python's
Language Reference for more). If you don't know what a 'primary' is, think of
them as variables. They may refer to any Python value: strings, numbers, None,
tuples, tuple items, tuple slices, lists, list items, list slices, dictionaries,
dictionary values, objects, and the return values of function and method calls.
When a template is processed each placeholder will be replaced with the string
representation of its value.  These string representations are identical to
those returned by Python's str() function, with the exception of \code{None}.
\code{None} is replaced with an empty string, or in other words nothing.

Cheetah finds the values for Placeholders in several places.  First, the
placeholder name can be one of Python's builtins, like \code{\$range} or
\code{\$len}.  Second, the name can refer to a variable in Cheetah's
\code{``searchList''}.  Third, the name can refer to a local variable, such as
\code{\$i} in a for loop, or an imported module name, such as \code{\#import
math \ldots \$math.sin(0.5)}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output From Complex Expressions: \#echo}
\label{output.echo}

The \code{\#echo} directive is used to echo the output from expressions that
can't be written as simple \$placeholders.  It serves the same purpose as ASP's
<\%=EXPR\%> tag.

\begin{verbatim}
Here is my #echo ','.join(['silly']*5) # example 
\end{verbatim}

In this example, the second \code{\#} serves to end the \code{\#echo} directive,
allowing plain text to follow it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Silencing The Output From Expressions: \#silent}
\label{output.silent}

The \code{\#silent} directive is used to silence the output from any
expressions that must be excuted.  It is similar to ASP's $<$\% EXPR \%$>$ tag.

\begin{verbatim}
#silent $myList.reverse()
#silent $myList.sort()
Here is #silent $covertOperation() # nothing
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Caching Output}
\label{output.caching}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Caching individual placeholders}
\label{output.caching.placeholders}

By default, the values of each \code{\$placeholder} is retrieved and
interpolated for every request. It is possible to cache the values individual
\code{\$placeholders}
                         
If you want to cache the value of a single \code{\$placeholder} during the first
request, add an asterisk after the \$ sign.  \code{\$var} becomes \code{\$*var}.

If you only need to update the cache at specific time intervals use this form:
\code{\$*<interval>*variable} , where \code{<interval>} is the interval.  The
time interval can be specified in seconds (5s), minutes (15m), hours (3h), days
(2d) or weeks (1.5w). The default is minutes.

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

$var ${var}           ## dynamic - will be reinterpolated for each request
$*var2 $*{var2}       ## static - will be interpolated only once at start-up
$*5*var3 $*5*{var3}   ## timed refresh - will be updated every 5 minutes.

</BODY>
</HTML>
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Caching entire regions}
\label{output.caching.regions}

The \code{\#cache} directive is used to cache a region of content in a template.
It accepts several keyword arguments, which are demonstrated in the examples
below.  Cached regions can be given an 'id', which can be used to
programmatically refresh a region with the \code{Template.refreshCache(id)}
method.  Cached regions can also be invalidated according to a user-specified
\code{test} conditions.

\begin{verbatim}
#cache timer='30m', ID='cache1'
#for $cust in $customers
$cust.name:
$cust.street - $cust.city
#end for
#end cache
\end{verbatim}

\begin{verbatim}
#cache id='sidebar', test=$isDBUpdated
## do something
#end cache

#cache id='sidebar2', test=($isDBUpdated or $someOtherCondition)
## do something
#end cache
\end{verbatim}

The \code{\#cache} directive cannot be nested.

We are planning to add a \code{'varyBy'} keyword argument in the future that
will allow a separate cache instances to be created for a variety of conditions,
such as different query string parameters or browser types. This is inspired by
ASP.net's varyByParam and varyByBrowser output caching keywords.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#raw}
\label{output.raw}

Any section of a Template Definition that is inside a \code{\#raw} ...
\code{\#end raw} tag pair will be printed verbatim without any parsing of
\$placeholders or other directives. This can be very useful for debugging, or
for Cheetah examples and tutorials.

\code{\#raw} may appear similar to HTML's \code{<PRE>} tag and LaTeX's
\code{\\verbatim\{\}} tag, but unlike those tags, \code{\#raw} does not cause
the body to appear in a special font or typeface.  It can't, because Cheetah
doesn't what a font is.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#include}
\label{output.include}

The \code{\#include} directive is  used to include text from outside the
template definition.  The text can come from external files or from
\code{\$placeholder} variables.  When working with external files Cheetah will
monitor for changes to the included file and update as necessary.  

This demonstrates its use with external files:
\begin{verbatim}
#include "includeFileName.txt"
\end{verbatim}
The content of "includeFileName.txt" will be parsed for Cheetah syntax.

And this example demonstrates use with \code{\$placeholder} variables:
\begin{verbatim}
#include source=$myParseText
\end{verbatim}
The value of \code{\$myParseText} will be parsed for Cheetah syntax. This is not
the same as simple placing the \$placeholder tag ``\code{\$myParseText}'' in
your template definition.  In the latter case, the value of \$myParseText would
not be parsed.

By default, included text will be parsed for Cheetah tags.  The argument
``\code{raw}'' can be used to suppress the parsing.

\begin{verbatim}
#include raw "includeFileName.txt"
#include raw source=$myParseText
\end{verbatim}

Cheetah wraps each chunk of \code{\#include} text inside a nested
\code{Template} object.  These nested templates share the same \code{searchList}
as the top-level template. But, unlike PHP, their Cheetah code must be
self-contained.  For example, all \code{\#for} and \code{\#if} blocks started
inside an \code{\#include} must be terminated in that include. \code{\#set}
variables are only visible across includes if the \code{\#set global} keyword is
used.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#slurp}
\label{output.slurp}

The \code{\#slurp} directive eats up the trailing newline on the line it
appears in, joining the following line onto the current line.


It is particularly useful in \code{\#for} loops:
\begin{verbatim}
#for $i in range(5)
$i #slurp
#end for
\end{verbatim}
outputs:
\begin{verbatim}
0 1 2 3 4
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ouput Filtering and \#filter}
\label{output.filter}

Output from \code{\$placeholders} is passed through an ouput filter.  By default
the filter just returns a string representation of the placeholder's value,
unless it is \code{'None'}, in which case it returns an empty string. 

The ouput filter can be specified via the \code{'outputFilter'} keyword to the
\code{Template} class' constructor, or at run-time using the \code{\#filter}
directive. The \code{Cheetah.Filters} module contains several filters.
The current filters are:

\begin{description}
\item{\code{Filter}}
     The default filter, which converts None to '' and everything else to
     \code{str(whateverItIs)}.  This is the base class for all other filters.
\item{\code{ReplaceNone}}
     Same.
\item{\code{MaxLen}}
     Same but truncate the value if it's longer than a certain length.
     (TODO: how to specify the length?)
\item{\code{Pager}}
     Output a "pageful" of a long string.  After the page, output HTML
     hyperlinks to the previous and next pages.  This filter uses several
     environmental variables and other variables, which will be documented in
     the future.
\item{\code{WebSafe}}
     Same as default but convert HTML-sensitive characters ('<', '\&', '>')
     to HTML entities.  This filter is currently untested.
\end{description}

More will be written about output filtering in future versions of this guide.

%% @@MO: Tavis TODO: rewrite this subsection.


% Local Variables:
% TeX-master: "users_guide"
% End:      

