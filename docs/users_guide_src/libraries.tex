%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Template and other libraries}
\label{libraries}

Cheetah comes ``batteries included'' with libraries of macros, templates and
other objects you can use in your own programs. If you develop your own, please
consider posting them on the mailing list so others can benefit. 

Some useful functions, and other objects, used by Cheetah are in the
\code{Cheetah.Utilities} module.  All utility modules contributed by third
parties are in the \code{Cheetah.Tools} package.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Template libraries}
\label{libraries.templates}

The \code{Cheetah.Templates} package contains stock templates that you can
either use as is, or extend by using the \code{\#def} directive to redefine
specific {\bf blocks}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Cheetah.Templates.SkeletonPage}
\label{libraries.templates.skeletonPage}

A stock template class that will be very useful for web developers is defined in
the \code{Cheetah.Templates.SkeletonPage} module.  The \code{SkeletonPage}
template class is generated from the following Cheetha source code:

\begin{verbatim}
$*docType
<HTML>
####################
#block headerComment
<!-- This document was autogenerated by Cheetah. Don't edit it directly!

Copyright $currentYr() - $*siteCopyrightName - All Rights Reserved.
Feel free to copy any javascript or html you like on this site,
provided you remove all links and/or references to $*siteDomainName
However, please do not copy any content or images without permission.

$*siteCredits

-->

#end block 
#####################

#################
#block headTag
<HEAD>
<TITLE>$*title</TITLE>
$*metaTags()
$*stylesheetTags()
$*javascriptTags()
</HEAD>
#end block 
#################


#################
#block bodyTag
$bodyTag()
#end block 
#################

#block writeBody
This skeleton page has no flesh. Its body needs to be implemented.
#end block 

</BODY>
</HTML>
\end{verbatim}

You can redefine any of the blocks defined in this template by writing a new
template that \code{\#extends} SkeletonPage.  

\begin{verbatim}
#def 
Here's my new body. I've got some flesh on my bones now.
#end redefine bodyContents
\end{verbatim}

All of the \$placeholders used in the \code{SkeletonPage} template definition
are attributes or methods of the \code{SkeletonPage} class.  You can reimplement
them as you wish in your subclass.  Please read the source code of the file
\code{src/Templates/SkeletonPage.py} before doing so.  

You'll need to understand how to use the following methods of the
\code{SkeletonPage} class: \code{\$metaTags()}, \code{\$stylesheetTags()},
\code{\$javascriptTags()}, and \code{\$bodyTag()}.  They take the data you
define in various attributes and renders them into HTML tags.

\begin{itemize}
\item {\bf metaTags()} -- Returns a formatted vesion of the self._metaTags
     dictionary, using the formatMetaTags function from \code{Cheetah.Macros.HTML}
\item {\bf stylesheetTags()} -- Returns a formatted version of the
     \code{self._stylesheetLibs} and \code{self._stylesheets} dictionaries.  The
     keys in \code{self._stylesheets} must be listed in the order that they
     should appear in the list \code{self._stylesheetsOrder}, to ensure that the
     style rules are defined in the correct order.
\item {\bf javascriptTags()} -- Returns a formatted version of the
     \code{self._javascriptTags} and \code{self._javascriptLibs} dictionaries.
     Each value in \code{self._javascriptTags} should be a either a code string
     to include, or a list containing the JavaScript version number and the code
     string. The keys can be anything.  The same applies for
     \code{self._javascriptLibs}, but the string should be the SRC filename
     rather than a code string.
\item {\bf bodyTag()} -- Returns an HTML body tag from the entries in the dict
     \code{self._bodyTagAttribs}.
\end{itemize}

The class also provides some convenience methods that can be used as
\$placeholders in your template definitions:

\begin{itemize}
\item {\bf imgTag(self, src, alt='', width=None, height=None, border=0)} --
     Dynamically generate an image tag.  Cheetah will try to convert the
     ``\code{src}'' argument to a WebKit serverSidePath relative to the
     servlet's location. If width and height aren't specified they are
     calculated using PIL or ImageMagick if either of these tools are available.
     If all your images are stored in a certain directory you can reimplement
     this method to append that directory's path to the ``\code{src}'' argument.
     Doing so would also insulate your template definitions from changes in your
     directory structure.
\end{itemize}

See the file \code{examples/webware_examples/cheetahSite/SiteTemplate.tmpl} for
an extended example of how \code{SkeletonPage} can be used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cheetah.Tools}
\label{libraries.tools}

As mentiond above, utility modules contributed by third parties are stored in
the \code{Cheetah.Tools} package. It currently contains:

\begin{itemize}
\item {\bf Cheetah.Tools.RecursiveNull} -- Nothing, but in a friendly way.  Good
     for filling in for objects you want to hide.  If \code{\$form.f1} is a
     RecursiveNull object, then \code{\$form.f1.anything["you"].might("use")} will
     resolve to the empty string. Contributed by Ian Bicking.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cheetah.SettingsManager}
\label{libraries.SettingsManager}

The \code{SettingsManager} class in the \code{Cheetah.SettingsManager} module is
a mixin class that provides facilities for managing application settings.  
SettingsManager is designed to:
\begin{itemize}
\item work well with nested settings dictionaries of any depth
\item be able to read/write \code{.ini style config files} (or strings)
\item be able to read settings from Python src files (or strings) so that
     complex Python objects can be stored in the application's settings
     dictionary.  For example, you might want to store references to various
     classes that are used by the application and plugins to the application
     might want to substitute one class for another.
\item allow sections in \code{.ini config files} to be extended by settings in
     Python src files.  If a section contains a setting like
     ``\code{importSettings=mySettings.py}'', \code{SettingsManager} will merge
     all the settings defined in ``\code{mySettings.py}'' with the settings for
     that section that are defined in the \code{.ini config file}.
\item maintain the case of setting names, unlike the ConfigParser module
\end{itemize}

Cheetah uses \code{SettingsManager} to manage its configuration settings.
\code{SettingsManager} might also be useful in your own applications. See the
source code and docstrings in the file \code{src/SettingsManager.py} for more
information. If there is sufficient interest in \code{SettingsManager} we will
release it as a standalone module.


% Local Variables:
% TeX-master: "users_guide"
% End:      
