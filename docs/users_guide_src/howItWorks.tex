\section{How Cheetah Works}
\label{howWorks}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Template Class}
\label{howWorks.templateClass}

The heart of Cheetah is the \code{Template} class in the
\code{Cheetah.Template} module. It serves two purposes. First, its constructor
accepts a {\bf template definition} in a string or a file (filename or file
object).  Cheetah compiles the template definition into a Python class (the
{\bf generated class}). Second, \code{Template} itself serves as the base class
for the generated class.  \code{Template} subclasses Webware's
\code{HTTPServlet} class when available, so the generated class can be used
as a Webware servlet.

A template is compiled automatically the first time it's {\bf filled}.
(Filling is what you do when you make a finished string from the template,
with all the placeholder values substituted in.) If you use a \code{Template}
object as in the previous two examples (sections \ref{intro.whatIs} and
\ref{gettingStarted.tutorial}), the generated class is overlaid into the
template object itself.  That is, the generated class is a dynamic superclass
that affects only that \code{Template} instance, not any other other
\code{Template} instances.  Don't worry if you don't understand this; 
it does the ``right thing'' behind the scenes.

If you instead precompile the template by running the \code{cheetah-compile}
program below, the hidden generated class is exposed.  It's written to a
file, with some boilerplate code around it to make a bona fide Python module
(called a {\bf .py template module}).  This ``freezes'' the class.  Anytime
later you can ``unfreeze'' it by importing and instantiating the class.  The 
advantage of this is speed: compile once, use many times.  Plus, if Python
has made a .pyc or .pyo file, you can skip Python's compilation step too.
The speed difference is negligable if you templates just occasionally,
because every template operation seems to be instantaneous, but it may make a
difference for applications such as Webware that use many templates a second.

To fill a template, you call its {\bf main method}.  This is normally 
\code{.respond()}, but under certain circumstances it's \code{.writeBody()} or
a user-defined name.  (Section \ref{inheritanceEtc.implements} explains why
the method name is not always the same.)  However, \code{.\/\_\_str\_\_()} is
always an alias for the main method, so you can always use
\code{print\ myTemplateInstance} or \code{str(myTempateInstance)} to fill it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Constructing Template Objects}
\label{howWorks.constructing}

Here are typical ways to create a template object:
\begin{description}
\item{\code{templateObj = Template("The king is a \$placeholder1.")}}
     \\ Pass the Template Definition as a string.
\item{\code{templateObj = Template(file="fink.tmpl")}}
     \\ Read the Template Definition from a file named "fink.tmpl".  
\item{\code{templateObj = Template(file=f)}}
     \\ Read the Template Definition from file-like object 'f'.
\item{\code{templateObj = Template("The king is a \$placeholder1.", searchList=[dict, obj])}}
     \\ Pass the Template Definition as a string.  Also pass two Namespaces for
     the searchList: a dictionary 'dict' and an instance 'obj'.
\item{\code{templateObj = Template(file="fink.txt", searchList=[dict, obj])}}
     \\ Same, but pass a filename instead of a string.
\item{\code{templateObj = Template(file=f, searchList=[dict, obj])}}
     \\ Same with a file object.
\end{description}

The constructor accepts the following keyword arguments:

\begin{description}
\item{{\bf source}}
     The template definition as a string.  You may omit the \code{source=}
     prefix {\em if it is the first argument}, as in all the examples above.
     The source can be a string literal in your module, or read from a database
     or other data structure.
\item{{\bf file}}
     A filename or file object containing the template definition.
     A filename must be a string, and a file object must be open for reading.
\item{{\bf searchList}}
     A list of objects to search for \code{\$placeholder} values.
\item{{\bf filter}}
     A class that will format every \code{\$placeholder} value.  You may
     specify a class object or string.  If a class object,
     it must be a subclass of \code{Cheetah.Filters.Filter}.  If a string, it
     must be the name of one of the filters in filtersLib module (see next 
     item).
     (You may also use the \code{\#filter} directive (section
     \ref{output.filter}) to switch filters at runtime.)
\item{{\bf filtersLib}}
     A module containing the filters Cheetah should look up by name.  The
     default is \code{Cheetah.Filters}.  All classes in this module that are
     subclasses of \code{Cheetah.Filters.Filter} are considered filters.
\item{{\bf errorCatcher}}
     A class to handle \code{\$placeholder} errors.  You may
     specify a class object or string.  If a class object,
     it must be a subclass of \code{Cheetah.ErrorCatchers.ErrorCatcher}.  
     If a string, it must be the name of one of the error catchers in
     \code{Cheetah.ErrorCatchers}.  This is similar to the 
     \code{\#errorCatcher} directive 
     (section \ref{errorHandling.errorCatcher}).
\item{{\bf compilerSettings}}
     A dictionary (or dictionary hierarchy) of settings that change Cheetah's
     behavior.  Not yet documented.
\end{description}

You {\em must} specify either {\bf source} or {\bf file}, but not both.  
EXCEPTION: When using a precompiled template class created by
\code{cheetah compile}, you do {\em not} specify a {\bf source} or {\bf
file} argument, since the source is built into the class.  You may, however,
use the other arguments if you wish.

\begin{verbatim}
from MyPrecompiledTemplate import MyPrecompiledTemplate
t = MyPrecompiledTemplate()
t.name = "Fred Flintstone"
t.city = "Bedrock City"
print t
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{cheetah-compile and .py template modules}
\label{howWorks.cheetah-compile}

% @@MO: Talk about cheetah-compile vs 'cheetah compile'.

If your application requires only a few short template definitions, you can
just put them in your modules as strings.  But if your application has large
templates or many templates, it's more convenient to put each in a separate
*.tmpl file and use Cheetah's compiler to convert it into a *.py template
module.  A {\bf .py template module} is a Python module with the same name as
the template, containing the generated class which is also named after the
template.  

Run ``\code{cheetah compile --help}'' from the command line after installing
Cheetah to get usage information.  The most common usage is
``\code{cheetah compile -R}'', which will convert all the *.tmpl files in the
current directory and its subdirectories.


There are actually three ways to invoke the compiler:
\begin{verbatim}
cheetah compile ...
cheetah -c ...
cheetah-compile ...
\end{verbatim}
All three ways are identical and accept the same command-line arguments.
(The separate program \code{cheetah-compile} exists for backward compatibility.
This Guide also uses the term cheetah-compile extensively because it stands out
without requiring quotes.)

When cheetah-compile converts {\bf FILENAME.tmpl} in some directory, it
overwrites {\bf FILENAME.py} in the same directory if it exists, after backing
it up to FILENAME.py\_bak.  For this reason, you should make changes to the
\code{.tmpl} version of the template rather than to the \code{.py} version.

For the same reason, if your template requires custom Python methods or
other Python code, don't put it in the \code{FILENAME.py} file.  Instead, put
it in a separate base class and use the \code{\#extends} directive to
inherit from it.

Because FILENAME will be used as a class and module name, it must be a valid
Python identifier.  For instance, \code{cheetah compile spam-eggs.tmpl} is 
illegal because of the hyphen ("-").  This is sometimes inconvenient when
converting a site of HTML files into Webware servlets.  Fortunately, the
directory it's in does not have to be an identifier.

One of the advantages of cheetah compile is that you don't lose any
flexibility.  The generated class contains all \code{\#attr} values and
\code{\#def}/\code{\#block} values as ordinary attributes and methods, so you
can read the values individually from other Python tools for any kind of custom
processing you want.  For instance, you can extract the titles of all
your templates into a database, or find all the servlets with a certaion
\code{\$author} value.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Some trivia about .py template modules}
\label{howWorks.pyTrivia}

We won't look inside .py template modules in this Guide except to note that
they are very different from template definitions.  The following template
definition fragment:

\begin{verbatim}
The number is $Test.unittest.main.
\end{verbatim}

compiles to this:

\begin{verbatim}
write("The number is ")  
write(filter(VFN(VFS(SL,"Test.unittest",1),"main",0)
write(".")
\end{verbatim}

In the upcoming Cheetah Developers' Guide, we'll look at .py template
modules in depth, and see what the various directives compile to.
But you are welcome to take a peek at some .py template modules yourself
if you're curious about what Cheetah does under the hood.  It's all
regular Python code: writing strings and function calls to a file-like
object.

Looking at a .py template module may also help you see why something
doesn't work, by seeing what Cheetah thought you meant.  It also helps 
discourage you from modifying the .py file yourself, because who wants to
keep all those function calls and arguments straight?  Let the computer
do the drudgery work.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Running your .py template module as a standalone script}
\label{howWorks.standalone}

In addition to importing your .py template module file into a Python
script or using it as a Webware servlet, you can also run it from the
command line as a standalone program.  The program will print the filled
template on standard output.  This is useful while debugging the template,
and for producing formatted output in shell scripts.

When running the template as a program, you cannot provide a searchList or
set \code{self.} attributes in the normal way, so you must take
alternative measures to ensure that every placeholder has a value.
Otherwise, you will get the usual \code{NameMapper.NotFound} exception at
the first missing value.

Fortunately, there are three ways to supply values to .py template modules
run as standalone programs:

\begin{description}
\item{{\bf Default values}}  You can set default values in the template itself
     (via the \code{\#attr} or \code{\#def} directives) or in a Python
     superclass.
\item{{\bf Environment variables}} If you use the \code{--env} command-line
option, Cheetah will look in the environment for values.  This is the easiest
way to pass values from a shell script.
\item{{\bf A pickle file}}  If you use the \code{--pickle PICKLE\_FILE} option, 
     Cheetah will unpickle the file and place the resulting data structure in
     the searchList.    See the standard Python modules \code{pickle} and
     \code{cPickle} for more information.  (The truly masochistic who love
     filters can even use \code{--pickle -} to read the pickle data from
     standard input.)
\end{description}

You can always run \code{python FILENAME.py --help} to see all the command-line
options your template program accepts.  (That's a double hyphen before the
``help'', even if LaTeX misformats it as single hyphen.)

Cheetah .py templates that will be used as Webware servlets can also be 
debugged this way.  The only caveat is that if they do any processing that
tries to call back into a live web transaction (such as looking for form
input data), they will raise an exception since there is no web transaction
in progress.  Those servlets must be debugged by calling them through the
web.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Object-Oriented Documents}
\label{howWorks.objoriented}

Because Cheetah documents are actually class definitions, templates may inherit
from one another in a natural way, using regular Python semantics. For
instance, consider this template, FrogBase.tmpl:

\begin{verbatim}
#def title
This document has not defined its title
#end def
#def htTitle
$title
#end def
<HTML><HEAD>
<TITLE>$title</TITLE>
</HEAD><BODY>
<H1>$htTitle</H1>
$body
</BODY></HTML>
\end{verbatim}

And its subclassed document, Frog1.tmpl:
\begin{verbatim}
#from FrogBase import FrogBase
#extends FrogBase
#def title
The Frog Page
#end def
#def htTitle
The <IMG SRC="Frog.png"> page
#end def
#def body
... lots of info about frogs ...
#end def
\end{verbatim}

This is a classic use of inheritance. The parent ``template'' is simply an
abstract superclass.  Each document specializes the output of its parent.
 For instance, here the parent defines
\code{\$htTitle} so that by default it's identical to whatever the 
\code{\$title} is, but it can also be customized.  This is because HTML's
\code{<TITLE>} tag cannot contain embedded tags, but we may want to use
embedded tags in the \code{H1} title for special effect.  Yet for simple
cases where the two are identical, we don't want to bother with
\code{\$htTitle} at all: we just want to set \code{\$title} and forget about
it.

In many other templating systems, you'd have to use case statements or
if-elseif blocks of some sort, repeated in many different sections of code.

While we show another Cheetah document inheriting from this parent, a Python
class can inherit from it just as easily. This Python class could define its
programmatically-driven value for \code{\$body} and \code{\$title}, simply by
defining body() and title() methods that return a string.  (Actually they
can return anything, but we'll get into that later.)  

\begin{verbatim}
from FrogBase import FrogBase
class Frog2(FrogBase):
	def title(self):
		return "Frog 2 Page"
	# We don't override .htTitle, so it defaults to "Frog 2 Page" too.
	def body(self):
		return " ... more info about frogs ..."
\end{verbatim}

Similarly, the Cheetah document can inherit from an arbitrary class. This
technique is used when combining Cheetah with Webware for Python
(chapter \ref{webware}): the base template for your site inherits (indirectly)
from the Webware HTTPServlet class.  The classes are sufficiently generic that
similar techniques should be possible for other systems.

({\em Note:}\ \code{FrogBase.tmpl} could be improved by using the
\code{\#block} directive, section \ref{inheritanceEtc.block}.)

% Local Variables:
% TeX-master: "users_guide"
% End:      

