\section{How Cheetah Works}
\label{howWorks}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Template Class}
\label{howWorks.templateClass}

The heart of Cheetah is the \code{Template} class in the \code{Cheetah.Template}
module. It serves two purposes. First, its constructor accepts a
\code{template definition} in a string or a file (filename or file object).
Cheetah compiles the template definition into a Python class (the 'generated
class'). Second, it is used as the base class for the generated classes.
\code{Template} subclasses Webware's \code{HTTPServlet} class when it is
available. Thus, the generated classes can be used as Webware servlets.

Generated template classes can either be used immediately or written to a Python
module file for future use. In the former case, the methods and attributes of
the generated class are dynamically bound to the instance of Template that did
the compiling. They are available as soon as compilation is complete. In the
latter case, Cheetah will wrap the generated class definition in some
boilerplate code to make a complete module definition.

The core method of a Cheetah generated class is \code{respond()}, as this is the
core method of Webware servlets. When this method is called, the Cheetah code in
the template is executed and the output is returned. For convenience, Cheetah
makes the \code{\_\_str\_\_} method an alias to \code{respond()}. Thus,
\code{``print myTemplateObj''} or \code{``print Template(sourceString)''} will
print the output of the template.

Classes generated from Cheetah templates can implement multiple methods. Cheetah
templates can extend other templates via subclassing and reimplementation of
methods. When one template subclasses another, the subclass template will
default to implementing the writeBody method, unless you use the
\code{\#implements} directive to tell Cheetah otherwise.

Cheetah source files use the \code{.tmpl} extension. The cheetah-compile script
that is packaged with Cheetah is a simple command line tool that facilitates
batch compilation of Cheetah source files. This script will be installed in a
system directory when Cheetah is installed.

To improve performance, Cheetah does "lazy compilation".  The compiling step is
delayed until the first time it is needed; e.g., the first time the template is
filled.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Object-Oriented Documents}
\label{howWorks.objoriented}

As Cheetah documents are actually class definitions, templates may inherit from
one another in a natural way, using regular Python semantics. For instance,
consider this template:

\begin{verbatim}
#def title
This document has not defined its title
#end def
#def htTitle
$title
#end def
<HTML><HEAD>
<TITLE>$title</TITLE>
</HEAD><BODY>
<H1>$htTitle</H1>
$body
</BODY></HTML>
\end{verbatim}

And its subclassed document:
\begin{verbatim}
#from SomeModule import TheTemplateAbove
#extends TheTemplateAbove
#def title
The Frog Page
#end def
#def htTitle
The <IMG SRC="Frog.gif"> page
#end def
\end{verbatim}

This is a classic use of inheritance. What we consider a "template" is simply an
abstract superclass. Each subdocument both defines its own behavior and
specializes the output. For instance, in this document we redefine
\code{\$htTitle} so that we can distinguish between the plain title that appears
in the HEAD and the potentially more complicated title that can appear in
\code{H1}.  This allows flexibility, while allowing most documents to ignore the
distinction (since by default \code{\$htTitle} is defined as \code{\$title}).

In many other templating systems, the solution to this sort of problem is
implemented with case statements (in whatever form they take) often placed in
many different sections of code. This is the classic problem that arises with
purely procedural programming languages, and Cheetah uses a classical approach
to solve it.

This is also a good way to mix Cheetah and Python code. Cheetah is not and does
not try to be the right language for everything you want to do (in contrast to
PHP, for instance). Instead it tries to focus on display logic and integrate
easily with Python code.

Consider the first example template: while we show another Cheetah document
inheriting from it, a Python class could inherit from it just as easily. This
Python class could define its programmatically-driven value for \code{\$body}
and \code{\$title}, simply by defining body() and title() methods.

Similarly, the Cheetah document can inherit from an arbitrary class. This
technique is used when combining Cheetah with Webware for Python: the base
template for your site inherits (indirectly) from the Webware HTTPServlet class.
The classes are sufficiently generic that similar techniques should be possible
for other systems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Constructing Template Objects}
\label{howWorks.constructing}

% The \code{Template} class' constructor accepts either a source string or a
% 'file' keyword argument, but not both.  In addition, you may use the
% 'searchList' keyword argument to pass a list of Namespaces for the
% searchList.  

Here are typical ways to create a template object:
\begin{description}
\item{\code{templateObj = Template("The king is a \$placeholder1.")}}
     \\ Pass the Template Definition as a string.
\item{\code{templateObj = Template(file="fink.tmpl")}}
     \\ Read the Template Definition from a file named "fink.tmpl".  
\item{\code{templateObj = Template(file=f)}}
     \\ Read the Template Definition from file-like object 'f'.
\item{\code{templateObj = Template("The king is a \$placeholder1.", searchList=[dict, obj])}}
     \\ Pass the Template Definition as a string.  Also pass two Namespaces for
     the searchList: a dictionary 'dict' and an instance 'obj'.
\item{\code{templateObj = Template(file="fink.txt", searchList=[dict, obj])}}
     \\ Same, but pass a filename instead of a string.  The \code{None} is
     required here to represent the missing Template Definition string -- this
     due to Python's rules for positional parameters.
\item{\code{templateObj = Template(file=f, searchList=[dict, obj])}}
     \\ Same with a file object.
\end{description}

The constructor accepts the following keyword arguments:

\begin{description}
\item{{\bf source}}
     The template definition as a string.  
\item{{\bf file}}
     A filename or file object containing the template definition.
     A filename must be a string, and a file object must be open for reading.
\item{{\bf searchList}}
     A list of objects to search for \code{\$placeholder} values.
\item{{\bf filter}}
     A class that will format every \code{\$placeholder} value.  You may
     specify a class object or string.  If a class object,
     it must be a subclass of \code{Cheetah.Filters.Filter}.  If a string, it
     must be the name of one of the filters in filtersLib module (see next 
     item).
     (You may also use the \code{\#filter} directive (section
     \label{output.filter}) to switch filters at runtime.)
\item{{\bf filtersLib}}
     A module containing the filters Cheetah should look up by name.  The
     default is \code{Cheetah.Filters}.  All classes in this module that are
     subclasses of \code{Cheetah.Filters.Filter} are considered filters.
\item{{\bf errorCatcher}}
     A class to handle \code{\$placeholder} errors.  You may
     specify a class object or string.  If a class object,
     it must be a subclass of \code{Cheetah.ErrorCatchers.ErrorCatcher}.  
     If a string, it must be the name of one of the error catchers in
     \code{Cheetah.ErrorCatchers}.  This is similar to the 
     \code{\#errorCatcher} directive 
     (section \ref{errorHandling.errorCatcher}).
\item{{\bf compilerSettings}}
     A dictionary (or dictionary hierarchy) of settings that change Cheetah's
     behavior.  Not yet documented.
\end{description}

You must specify either {\bf source} or {\bf file}, but not both.  All other
arguments are optional.  If you are using {\bf source}, you may omit the
\code{source=} prefix {\em if it is the first argument}, as in all the examples
above.

If you spell a keyword wrong, it will be ignored rather than causing an error.
So check your spelling!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{cheetah-compile: converting .tmpl files into .py files}
\label{howWorks.tmpl2py}
\label{howWorks.cheetah-compile}

If your application requires only a few short template definitions, you can
just put them inline in your modules, and create Template objects like the
examples in section \ref{gettingStarted.tutorial}.  But if your application
has large templates or many templates, you will find it more convenient to
put each template definition in a separate *.tmpl file, and use the
\code{cheetah-compile} program to convert it into a *.py file; that is, a
Python module named after the template, containing the generated class
which is also named after the template.  

\code{cheetah-compile} is a small shell script parses template definition
files and creates equivalent Python modules.  On Unix systems, it is installed
into a system directory like \code{/usr/local/bin}, so you can use it without
specifying the absolute path of the script.  On Windows systems, you must
specify the full path (\code{<cheetahRoot>/bin/cheetah-compile}). Type
``\code{cheetah-compile}'' from the command line after installing Cheetah to
get usage information.  The most common usage is ``\code{cheetah-compile -R}'',
which will convert all the *.tmpl files in the current directory
and its subdirectories.

If you run \code{cheetah-compile} on a file FILENAME.tmpl, it will
overwrite FILENAME.py if it exists in the same directory, no matter what
FILENAME.py contains.  For this reason, you should make changes to the
\code{.tmpl} version of the template rather than the \code{.py} version.  Any
\code{.py servlet files} that are about to be overwritten will are
automatically backed up with the extension \code{.py\_bak}.

Because FILENAME will be used as a class and module name, it must be a valid
Python identifier.  For instance, \code{cheetah-compile spam-eggs.tmpl} is 
illegal because of the hyphen ("-").

One of the advantages of \code{cheetah-compile} is that you don't lose any
flexibility.  The generated class contains all \code{\#attr} values and
\code{\#def}/\code{\#block} values as ordinary attributes and methods of the
template class, so you can read the values individually from other Python
tools for any kind of custom processing you want.  For instance, if you want to
put the titles of all your servlets into a database.

For the same reason, if your template requires custom Python methods or
other Python code, don't put it in the \code{FILENAME.py} file.  Instead, put
it in a separate base class and use the \code{\#extends} directive in the
template definition to indicate the superclass.  Or put the Python code
in the calling routine (the routine that instantiates and uses the template
object).

%% @@MSO: Not using the term '.tmpl/.py servlet files' here because they
%% aren't necessarily Webware servlets.
%% @@TR: but it might be best for simplicity to assume that they are.
%% @@MSO: No, because we should document basic standalone Cheetah first, then
%% show how it integrates with Webware.

% Local Variables:
% TeX-master: "users_guide"
% End:      

