%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comments}
\label{comments}

Comments are used to mark notes, explanations, and decorative text that should
not appear in the output.  Cheetah maintains the comments in the Python module
it generates from the Cheetah source code. There are two forms of the comment
directive: single-line and multi-line.

All text in a template definition that lies between two hash characters
(\code{\#\#}) and the end of the line is treated as a single-line comment and
will not show up in the output, unless the two hash characters are escaped with
a backslash.
\begin{verbatim}
##=============================  this is a decorative comment-bar
$var    ## this is an end-of-line comment
##=============================
\end{verbatim}

Any text between \code{\#*} and \code{*\#} will be treated as a multi-line
comment.
\begin{verbatim}
#*
   Here is some multiline
   comment text
*#
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Whitespace around comments}
\label{comments.whitespace}

Putting a comment on the same line as a directives may cause more whitespace in
the output than you intend because the whitespace before the comment is not
squeezed out.  To avoid this problem, put comments on separate lines with no
whitespace before them, and you can skip this section.  If you still want to
put comments on the same line as directives, read on.

After a directive on the same line, you need an extra \code{\#} to end the
directive:
\begin{verbatim}
#if $count == 0 # ## if the records are missing
\end{verbatim}

However, this will insert an extra space in the output (the space before the
comment), appearing on its own line.  You can eliminate the space by eliminating
the space (!): 
\begin{verbatim}
#if $count == 0 ### if the records are missing
\end{verbatim}
but then you'll get an empty line in the output.  To put a comment on that
line {\em and} make the line not show up on the output, you need to use
\code{\#slurp} with no spaces around it, as in example 3 below:

\begin{verbatim}
#attr $animals = ('horse', 'donkey')
Example 1:
#for $animal in $animals ### La la!
The zoo contains $animal.
#end for# ## $animal.
******************************************
Example 2:
#for $animal in $animals
The zoo contains $animal.
#end for
******************************************
Example 3:
#for $animal in $animals##slurp### La la!
The zoo contains $animal.
#end for##slurp### $animal.
*****************************************
\end{verbatim}

And the output:

\begin{verbatim}
Example 1:

The zoo contains horse.

The zoo contains donkey.
 
******************************************
Example 2:
The zoo contains horse.
The zoo contains donkey.
******************************************
Example 3:
The zoo contains horse.
The zoo contains donkey.
*****************************************

\end{verbatim}

But obviously, a line like
\begin{verbatim}
#for $animal in $animals##slurp### La la!
\end{verbatim}
can be confusing to read.  You have to count hash characters to tell that the
\code{\#\#} before \code{slurp} is not the beginning of a comment but instead
is two directives next to each other.  Likewise, you have to remember
that the first hash in \code{\#\#\#} ends the \code{slurp} directive, and the
next two begin the comment.  Again, you can avoid all this confusion by putting
your comments on separate lines.

Modifying Cheetah to remove whitespace before comments and to remove lines
that consist only of directives, whitespace and comments is on the TODO list.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Docstring Comments}
\label{comments.docstring}

Python modules, classes, and methods can be documented with inline
'documentation strings' (aka 'docstrings').  Docstrings, unlike comments, are
accesible at run-time. Thus, they provide a useful hook for interactive help
utilities.  

Cheetah comments can be transformed into doctrings by adding one of the
following prefixes:

\begin{verbatim}
##doc: This text will be added to the method docstring
#*doc: If your template file is MyTemplate.tmpl, running cheetah-compile
       on it will produce MyTemplate.py, with a class MyTemplate in it,
       containing a method .respond().  This text will be in the .respond()
       method's docstring. *#

##doc-method: This text will also be added to .respond()'s docstring
#*doc-method: This text will also be added to .respond()'s docstring *#

##doc-class: This text will be added to the MyTemplate class docstring
#*doc-class: This text will be added to the MyTemplate class docstring *#

##doc-module: This text will be added to the module docstring MyTemplate.py
#*doc-module: This text will be added to the module docstring MyTemplate.py*#
\end{verbatim}

\subsection{Header Comments}
\label{comments.headers}
Cheetah comments can also be transformed into module header comments using the
following syntax:

\begin{verbatim}
##header: This text will be added to the module header comment
#*header: This text will be added to the module header comment *#
\end{verbatim}

Note the difference between \code{\#\#doc-module: } and \code{header: }:
\code{cheetah-compile} puts \code{\#\#doc-module: } text inside the module docstring.  \code{header: } makes the text go {\em above} the docstring, as a
set of \#-prefixed comment lines.

% Local Variables:
% TeX-master: "users_guide"
% End:      
