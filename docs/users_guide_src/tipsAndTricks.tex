%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Miscellaneous Placeholder and Directive Tips}
\label{tips}

This chapter contains short stuff that doesn't fit anywhere else.

Remember to look at the wiki periodically for the most recent tips contributed
by users.  The mailing list also reveals tips as somebody posts a problem
they're having and others troubleshoot it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ASP-style tags}
\label{tips.ASP}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Placeholder Tips}
\label{tips.placeholder}

Here's how to do certain important lookups that may not be obvious.
For each, we show first the Cheetah expression and then the Python equivalent,
because you can use these either in templates or in pure Python mixin classes.
The Cheetah examples use NameMapper shortcuts (uniform dotted notation, 
autocalling) as much as possible.

To verify whether a variable exists in the searchList:
\begin{verbatim}
$varExists('theVariable')
self.varExists('theVariable')
\end{verbatim}
This is useful in \code{\#if} or \code{\#unless} constructs to avoid a
\code{\#NameMapper.NotFound} error if the variable doesn't exist.  For instance,
a CGI GET parameter that is normally supplied but in this case the user typed
the URL by hand and forgot the parameter (or didn't know about it).

To look up a variable in the searchList from a Python method:
\begin{verbatim}
self.getVar('theVariable')
self.getVar('theVariable', None)
self.getVar('theVariable', myDefault)
\end{verbatim}
This is the equivalent to \code{\$theVariable} in the template.  \code{getVar}
returns the second argument (\code{None} or \code{myDefault} if the variable is
missing; or, if there is no second argument, it raises raises
\code{NameMapper.NotFound}.  However, it usually easier to write your method
so that all needed searchList values come in as method arguments.  That way
the caller can just use a \$placeholder to specify the argument, which is
less verbose than you writing a getVar call.

To do a ``safe'' placeholder lookup that returns a default value if the
variable is missing:
\begin{verbatim}
$getVar('theVariable', None)
$getVar('theVariable', $myDefault)
\end{verbatim}

To get an environmental variable, put \code{os.environ} as one of the
elements in the searchList.  Or read the envvar in Python code and set a
placeholder variable for it.

Remember that variables found earlier in the searchList override same-name
variables located in a later searchList object.  Be careful when adding objects
containing other variables besides the ones you want (e.g., \code{os.environ},
CGI parameters).  The "other" variables may override variables your application
depends on, leading to hard-to-find bugs.  Also, users can inadvertently or
maliciously set an environmental variable or CGI parameter you didn't expect,
screwing up your program.  To avoid all this, know what your namespaces
contain, and place the namespaces you have the most control over first.  For
namespaces that could contain user-supplied "other" variables, don't put the
namespace itself in the searchList; instead, copy the needed variables into
your own "safe" namespace.

% @@ MO: If getVar() is called from Python, does errorCatcher apply?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Calling superclass methods, and why you have to}
\label{tips.callingSuperclassMethods}

If your template or pure Python class overrides a standard method or attribute of \code{Template}
or one of its base classes, you should call the superclass method in your
method to prevent various things from breaking.  The most common methods to
override are \code{.awake} and \code{.\_\_init\_\_}.  \code{.awake} is called
automatically by Webware early during the web transaction, so it makes a 
convenient place to put Python initialization code your template needs.
You'll definitely want to call the superclass \code{.awake} because it sets
up many wonderful attributes and methods, such as those to access the CGI input
fields.  

There's nothing Cheetah-specific to calling superclass methods, but because
it's vital, we'll recap the standard Python techniques here.

In Python >= 2.2, you can simply do:
\begin{verbatim}
from Cheetah.Template import Template
class MyClass(Template):
	def awake(self, trans):
		super(MyClass, self).awake(trans)
		... add your own great and exciting features here ...
\end{verbatim}
For Python < 2.2, you have to explicitly name the superclass and call the
method as an unbound method:
\begin{verbatim}
from Cheetah.Template import Template
from Cheetah.Servlet import Servlet
class MyClass(Template):
	def awake(self, trans):
		Servlet.awake(self, trans)
		... great and exciting features written by me ...
\end{verbatim}

[ @@MO: Need to test this.  .awake is in Servlet, which is a superclass
of Template.  Do we really need both imports?  Can we call
Template.awake? ]

To avoid hardcoding the superclass name in older Python, you can use this
function \code{callbase()}, which emulates \code{super()} for older versions of
Python.  It also works even \code{super()} does exist, so you don't have to
change your servlets immediately when upgrading.  Note that the argument
sequence is different than \code{super} uses.

\begin{verbatim}
===========================================================================
# Place this in a module SOMEWHERE.py .  Contributed by Edmund Lian.
class CallbaseError(AttributeError):
    pass

def callbase(obj, base, methodname='__init__', args=(), kw={},
    raiseIfMissing=None):
    try: method = getattr(base, methodname)
    except AttributeError:
        if raiseIfMissing:
            raise CallbaseError, methodname
        return None
    if args is None: args = ()
    return method(obj, *args, **kw)
===========================================================================
# Place this in your class that's overriding .awake (or any method).
from SOMEWHERE import callbase
class MyMixin:
        def awake(self, trans):
                args = (trans,)
                callbase(self, MyMixin, 'awake', args)
                ... everything else you want to do ...
===========================================================================
\end{verbatim}

% @@MO: Edmund wants us to mention delegation too, as an alternative to
% inheritance.  Contact elian@inbrief.net for details.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{All methods}
\label{tips.allMethods}

Here is a list of all the standard methods inherited by \code{Template} objects
and attributes.  Some of them exist for you to call, others are mainly used by
Cheetah but you can call them if you wish, and others are only for internal use
by Cheetah.  Do not use these method names in mixin classes (\code{\#extends},
section \ref{inheritanceEtc.extends}) unless you intend to override the
standard method.  

[Method list not written yet.]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Optimizing templates}
\label{tips.optimizing}

Here are some things you can do to make your templates fill faster and user
fewer CPU cycles.  Before you put a lot of energy into this, however, make
sure you really need to.  In many situations, templates appear to initialize
and fill instantaneously, so no optimization is necessary.  If you do find a
situation where your templates are filling slowly or taking too much memory or
too many CPU cycles, we'd like to hear about it on the mailing list.

Cache \$placeholders whose values don't change frequently.  (Section
\ref{output.caching}).

Use \code{\#set} for values that are very frequently used, especially if they
come out of an expensive operation like a deeply.nested.structure or a
database lookup.  \code{\#set} variables are compiled into Python local
variables, which have by far the fastest lookup time f any Python or Cheetah
variables.

Moving variable lookups into Python code may provide a speedup in certain
circumstances.  If you're just reading \code{self} attributes, there's no
reason to use NameMapper lookup (\$placeholders) for them.  NameMapper does
a lot more work than simply looking up a \code{self} attribute.  

On the other hand, if you don't know exactly where the value will come from
(maybe from \code{self}, maybe from the searchList, maybe from a CGI input
variable, etc), it's easier to just make that an argument to your method, and
then the template can handle all the NameMapper lookups for you:
\begin{verbatim}
#silent $myMethod($arg1, $arg2, $arg3)
\end{verbatim}
Otherwise you'd have to call \code{self.getVar('arg1')} etc in your
method, which is more wordy, and tedious.



% Local Variables:
% TeX-master: "users_guide"
% End:      
