%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using Cheetah with Webware}
\label{webware}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Background}
\label{webware.background}

{\bf Webware} is a 'Python-Powered Internet Platform' that uses servlets in a
manner similar to Java servlets.  {\bf WebKit} is the name of Webware's
application server.  For more details please visit
\url{http://webware.sourceforge.net}.

As Cheetah's core is flexible there are many ways to use it with Webware
servlets.  There are two broad categories: the {\bf Inheritance} approach and
the {\bf Containment} approach.  In the Inheritance approach the Template object
{\em IS} the servlet and its \code{.respond()} method is automatically called by
WebKit for each request.  All pre-request processing is handled via Cheetah.

In the Containment approach an instance of the Template class is contained
inside of a Webware servlet.  The servlet must explicitly call the Template
object's \code{.respond()}, or \code{.\_\_str\_\_()}, method for each request.  In
this case the servlet class can handle whatever per-request processing needs to
be done before it calls Cheetah.respond().

The Inheritance approach is the simplest and is best suited for building sites
from scratch. The Containment approach is slightly more complex and is best
suited for use with existing Webware servlets.  It is also ideal for cases where
you wish to use Cheetah for only a portion of the servlet's output, such as a
discussion-forum table at the bottom of a webpage.

There are two ways to use the Inheritance approach: automatically by creating
{\bf \code{.tmpl servlet files}} (e.g. ``myTemplate.tmpl'') or manually by
creating {\bf \code{.py servlet files}} (e.g. ``myServlet.py''). \code{.py
  servlet files} are Webware's default type of servlet file.  A \code{.tmpl
  servlet file} is a Cheetah specific type of servlet file that is converted
automatically into a \code{.py servlet file} that Webware understands.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using .tmpl servlet files}
\label{webware.tmpl}

As mentioned above a \code{.tmpl servlet file} is a Cheetah specific type of
servlet file that is converted automatically, or semi-automatically, into a
\code{.py servlet file} that Webware understands.  Working with \code{.tmpl
  servlet files} hides alot of extraneous details and is recommended for Cheetah
users who don't have a deep understanding of Python.

Section \ref{howWorks.tmpl2py} discussed how to convert .tmpl files to
.py files using the \code{cheetah-compile} command.

Cheetah has a Webware plugin that automatically converts a
\code{.tmpl servlet file} into a \code{.py servlet
  file} when the 
\code{.tmpl servlet file} is requested by a browser.  However, that plugin
is currently unavailable because it's being redesigned.  Until the 0.9.9
release of Cheetah, use \code{cheetah-compile} instead.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Writing .tmpl servlet files}
\label{webware.tmpl.writing}

Here's an example \code{.tmpl servlet file} with no Cheetah syntax in it:

\begin{verbatim}
## FILE: hello_world.tmpl ##
<HTML>
<HEAD><TITLE>Hello World - Test Servlet</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
\end{verbatim}

Here's the previous example with some Cheetah syntax.  Note that all lines that begin with
\code{\#\#} are comment lines.

\begin{verbatim}
## FILE: hello_world.tmpl ##
#def title
Hello World!
#end def
#def contents
Hello World!
#end def

<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
$contents
</BODY>
</HTML>
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The SkeletonPage framework}
\label{webware.skeletonPage}

Sect \ref{libraries.templates.skeletonPage} contains information on a stock
template that greatly simplifies defining the basic HTML structure of your web
page templates.  It is equivalent to Webware's \code{WebKit.Page} servlet and
is well worth the time spent learning how to use it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using the Containment approach}
\label{webware.containment}

With the containment approach your template obj does not repond directly to a
request from Webware's AppServer. Rather, you use a non-Cheetah-specific servlet
to handle the request and use one or more Cheetah template objects inside the
servlet's \code{.respond()} method and send their output via the 
\code{response.write()} method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Using \#include with the containment approach}
\label{webware.containment.includes}

Webware's ``\code{current working directory}'' probably isn't the directory that
your servlet files are sitting in.  All relative paths need to be adjusted so
they are relative to the servlet's directory and not Webware's \code{current
  working directory}.  Use Webware's \code{Servlet.serverSidePath()} method for
this purpose.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{User interaction in either approach}
%\label{webware.userInteraction}
%
%By {\bf user interaction} we mean the use of forms, query strings or sessions to
%create interactive pages that allow user interation with a website.
%[{\bf This section is under construction. Check back later.}]
%


% Local Variables:
% TeX-master: "users_guide"
% End:      
