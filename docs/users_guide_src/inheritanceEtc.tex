%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Imports, Inheritance, Declarations and Assignments}
\label{inheritanceEtc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#import and \#from directives}
\label{inheritanceEtc.import}

The \code{\#import} and \code{\#from} directives are used to import Python
modules or stuff from inside modules.  The syntax is identical to the import
syntax in Python.  Imported modules are visible globally to all methods in the
generated Python class.

\begin{verbatim}
#import math
#import math as mathModule
#from math import sin, cos
#from math import sin as _sin
\end{verbatim}

After the above imports, \code{\$math}, \code{\$mathModule}, 
\code{\$sin}, \code{\$cos} and \code{\$\_sin} may be used in 
\code{\$placeholders} and expressions.

The wildcard form \code{from MODULE import *} is not supported:
\begin{verbatim}
#from math import *         # ## No!  
$sin(8)                       ## Raises NameMapper.NotFound error at fill time.
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#extends}
\label{inheritanceEtc.extends}

Normally, the generated template class is a subclass of
\code{Cheetah.Template.Template}.  This gives it standard \code{Template}
functionality as well as making it usable as a Webware servlet.  However,
sometimes you want to inherit from a more general template (e.g., one
containing your generic site framework), or from a pure Python class (so you
can call its methods and attributes as placeholders.  The \code{\#extends}
directive allows you to specify which parent class to inherit from.  It is
equivalent to PSP's \code{``@page extends=''} directive. 

\begin{verbatim}
#from Cheetah.Templates.SkeletonPage import SkeletonPage
#extends SkeletonPage
\end{verbatim}

In the very near future, you won't need those \code{\#from ... import}
directives because \code{\#extends} will implicitly import whatever 
classes it needs, but for now the explicit imports are necessary.

Three rules: (A) you may inherit from only one superclass (no multiple
inheritance), (B) there may be at most one \code{\#extends} directive per
template, and (C) the highest-level superclass in the chain must be
\code{Cheetah.Template.Template}.  

Here's an example for a large web site that has not only a general site
template, but also a template for this section of the site, and several pure
Python classes too.  We'll begin with the highest-level superclass and
end with the specific page template:

\begin{verbatim}
1.  SiteLogic.py (pure Python class containing methods for the site)
        from Cheetah.Template import Template
	class SiteLogic(Template):

2.  Site.tmpl/py  (template containing the general site framework)
        #from SiteLogic import SiteLogic
	#extends SiteLogic

3.  SectionLogic.py  (pure Python class with helper code for the section)
        from Site import Site
	class SectionLogic(Site)

4.  Section.tmpl/py  (template with '#def' overrides etc. for the section)
	#from SectionLogic import SectionLogic
	#extends SectionLogic

5.  page1Logic.py  (pure Python class with helper code for the page)
        from Section import Section
	class indexLogic(Section):

6.  page1.tmpl/py  (template for a certain page on the site)
        #from page1Logic import page1Logic
	#extends page1Logic
\end{verbatim}

You may omit any files you don't need, or insert extra files as necessary, and
of course you may name the classes anything you want.  If your highest-level
site template (Site.tmpl/py) doesn't need a pure Python class (Site.py), it's
even easier: just omit the \code{\#from ...  import} and \code{\#extends} lines
in \code{Site.tmpl}, and it will automatically inherit from \code{Template}.

Pure Python classes with \code{.\_\_init\_\_()} methods should call their
parent's \code{.\_\_init\_\_()} method before doing anything else.  In Python
>= 2.2, it's easier:
\begin{verbatim}
# SiteLogic.py
from Cheetah.Template import Template
class SiteLogic(Template):
	def __init__(self):
		super(SiteLogic, self).__init__()
		... everything else you want to do ...
\end{verbatim}

In older versions of Python you must do this:
\begin{verbatim}
# SiteLogic.py
from Cheetah.Template import Template
class SiteLogic(Template):
	def __init__(self):
		Template.__init__(self)
		... everything else you want to do ...
\end{verbatim}

Section ?? has a function you can use to avoid hardcoding the name of the
superclass into your \code{.\_\_init\_\_()} method.

In older versions of Cheetah (until 0.9.12), you could list multiple classes
in the \code{\#extends} directive, thus doing multiple inheritance.  This 
feature was removed because it caused too much confusion, user errors and
Cheetah bugs.  However, your pure Python classes {\em may} do multiple
inheritance, as long as they properly initialize the template superclass 
(the one leading up toward \code{Template}) if they have an
\code{.\_\_init\_\_()} method.

For Webware servlets, it's easier to omit the \code{.\_\_init\_\_()} method
and override \code{.awake()} instead, since Webware automatically calls
\code{.awake()} at the beginning of the request.  But you'd have to call
the parent's \code{.awake()} in that case.  See section ??.

See the next section, \code{\#implements}, for an important issue to be aware
of when using \code{\#extends}, namely how it affects the generated class's
main method.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#implements}
\label{inheritanceEtc.implements}

% @@MO: Fully describe the main methods.

A template object has several methods, but there is always one {\bf main
method}, the one you call to fill the template.  By default, this method is
called \code{.respond()}.  However, you can use the \code{\#implements}
directive to change the name of that method.  You have to do this if you're
integrating Cheetah with an existing system, and the calling routine wants to
call another method name rather than \code{.respond()}.

EXCEPTION: if your template contains an \code{\#extends} directive but no
\code{\#implements}, the main method is \code{.writeBody()} instead of
\code{.respond()}.  Why?  Because that helps templates that are Webware
servlets function correctly.

So you must think about what your main method should be called and set
\code{\#implements} accordingly if necessary.

In any case, \code{.\/\_\_str\_\_()} is always an alias for the main method, no
matter what the main method is called.  So you can always call \code{str(t)} to
fill your template, or \code{print t} to fill and print it.  But of course, in
a Webware servlet you never use the \code{print} statement directly except for
debugging.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#set}
\label{inheritanceEtc.set}

\code{\#set} is used to create and update local variables at run time.
\code{\#set \$var = EXPRESSION}. The expression may be any Python expression.
Remember to preface variable names with \$, unless it is part of an
intermediate result in a list comprehension.

Here are some examples:
\begin{verbatim}
#set $size = $length * 1096
#set $buffer = $size + 1096
#set $area = $length * $width
#set $namesList = ['Moe','Larry','Curly']
#set $prettyCountry = $country.replace(' ', '&nbsp;')
\end{verbatim}

\code{\#set} variables are useful to assign a short name to a
\code{\$deeply.nested.value}, to a calculation, or to a printable version of
a value.  The last example above converts any spaces in the 'country' value
into HTML non-breakable-space entities, to ensure the entire value appears on
one line in the web browser.

\code{\#set} variables are also useful in \code{\#if} expressions, but
remember that complex logical routines should be coded in Python, not in
Cheetah!
\begin{verbatim}
#if $size > 1500
  #set $adj = 'large'
#else
  #set $adj = 'small'
#end if
\end{verbatim}

By default, \code{\#set} variables are not visible in method calls or include
files unless you use the \code{global} attribute: \code{\#set global \$var =
EXPRESSION}.  Global variables are visible in all methods, nested templates and
included files.  Use this feature with care to prevent surprises.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#attr}
\label{inheritanceEtc.attr}

The \code{\#attr} directive is used to declare new attributes of the generated Python
class.  It should be used to assign simple Python literals such as numbers or
strings.  

\begin{verbatim}
#attr myAttr = 1234
#attr myAttr2 = 'a string'
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#def}
\label{inheritanceEtc.def}

The \code{\#def} directive is used to declare new methods of the generated Python
class.  It is roughly analogous to Python's \code{def} statement.  Any Cheetah
code in the body of the \code{\#def} will be processed.  

\begin{verbatim}
#def myMeth()
This is the text in my method 
$a $b $c(123)  ## these placeholder names have been defined elsewhere
#end def

## and now use it...
$myMeth()
\end{verbatim}

The arglist and parentheses can be omitted:
\begin{verbatim}
#def myMeth
This is the text in my method 
$a $b $c(123)
#end def

## and now use it...
$myMeth
\end{verbatim}

Methods can accept arguments, and have defaults for those arguments.  Always use the 
\code{\$} before variable names:
\begin{verbatim}
#def myMeth($a, $b=1234)
This is the text in my method 
$a - $b
#end def

## and now use it...
$myMeth(1)
\end{verbatim}

The output from this last example will be:

\begin{verbatim}
This is the text in my method 
1 - 1234
\end{verbatim}

If a method already exists with the same name as the \code{\#def}, it will be replaced
with the new definition.  If the new \code{\#def} occurs in a subclass, it overrides the
parent's definition.  See the \code{\#extends} directive above for information about
subclasses.  Overriding is frequently used for blocks, which will be described next.

There is also a single line version of the \code{\#def} directive:

\begin{verbatim}
#attr adj = 'trivial'
#def myMeth: This is the $adj method 
$myMeth
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#block ... \#end block}
\label{inheritanceEtc.block}

The \code{\#block} directive allows you to mark sections of your template
that can be selectively reimplemented by subclasses of the template.  It is
very useful for selectively changing part of a template without having to
copy-paste-and-edit the entire thing.  The output from a template definition
that uses blocks will be identical to the output from the same template with
the \code{\#block and \#end block} tags removed. 

To reimplement the block, use the \code{\#def} directive.  The magical effect is that it
goes back and changes the output text {\em at the point the original block was
defined} rather than at the location of the reimplementation.

\begin{verbatim}
#block [blockName] 
[block contents] 
#end block [blockName]

#block testBlock
Text in the contents 
area of the block directive
#if $testIt
$getFoo() 
#end if
#end block testBlock
\end{verbatim}

\code{\#block} directives can be nested to any depth.

\begin{verbatim}
#block outerBlock
Outer block contents 

#block innerBlock1
inner block1 contents 
#end block innerBlock1

#block innerBlock2
inner block2 contents 
#end block innerBlock2

#end block outerBlock
\end{verbatim}

Note that the name of the block is optional for the \code{\#end block} tag.

Technically, \code{\#block} directive is equivalent to a \code{\#def} directive
followed immediately by a \code{\#placeholder} for the same name.  In fact,
that's what Cheetah does.  So \code{\#block} creates a method as well as
defining a block, and you may call this method using a placeholder if you want
its output to appear in other locations too.

Sometimes Cheetahites use the term "block" to refer to any multiline directive
(e.g., \code{\#for ... \#end for}).  Thus, the terms "for-blocks", "if-blocks",
etc.  These have nothing to do with the blocks described in this section, which
are methods created by the \code{\#block} directive.  It's just a coincidence
that the English language uses the same term for both things.  (Did you know 
that "run" has over fifty meanings in the dictionary?  And "take" has
seventy-three.  That's not counting phrases like "take off" and "run-in".)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#settings ... \#endSettings}
\label{inheritanceEtc.settings}

The \code{\#settings} directive works in tandem with Cheetah's
\code{SettingsManager} system to provide yet another way to set values for
\code{\#placeholders} to find.  It is best understood by reading the comments in
\code{\#SettingsManager.py} in conjunction with this documentation.

\code{SettingsManager} is a system for managing application settings.  An
Application may subclass \code{SettingsManager.SettingsManager} and gain access
to some sophisticated methods for getting and setting key/value pairs
("settings") individually, or in bulk from a dictionary or a hierarchy of
dictionaries.  You can pass in a dictionary of dictionaries (of dictionaries,
etc...) containing only the keys and subkeys (and subkeys, etc...) that have
changed, and SettingsManager will merge all the changes in.  SettingsManager can
also read settings in from modules, exec'able Python strings/files, and
strings/files in Python's standard \code{ConfigParser} format (aka Windows .ini
format).  Unlike ConfigParser, however, because it parses case-sensitively, and
automatically converts numeric values to numbers, 'None' to None, and 'true' and
'false' to Boolean true and false.

What does this have to do with Cheetah templates? When you have large sets of
hierarchically structured data that you want to make available to
\code{\$placeholders}, the (\code{\#settings} directive can be convenient
alternative to \code{\#attr} and \code{\#def}:

\begin{verbatim}
#settings
[SubSection1]
test = blarg

[SubSection2]
test = foo
#end settings
$settings.SubSection1.test

#settings python
SubSection1 = {
  'test':'blarg',
  }
SubSection2 = {
  'test':'foo',
  }
#end settings
$settings.SubSection1.test
\end{verbatim}

in your template and get the following output:

\begin{verbatim}
blarg

blarg
\end{verbatim}

The first stanza is in ConfigParser format (aka Windows .ini format)--note the
lack of \code{\$} before the key, and the lack of quotes around the value.  The
second stanza is in Python format, as if it were a Python module, with quotes,
but no \code{\$}.

You can also place your template object's settings dictionary in \code{the
searchList} so you can type \code{\$mySetting} instead of
\code{\$settings.mySetting}.

Dictionary merging can be turned off with the 'nomerge' keyword:

\begin{verbatim}
#settings python nomerge
SubSection1 = {
  'test':'blarg',
  }
SubSection2 = {
  'test':'foo',
  }
#end settings
$settings.SubSection1.test
\end{verbatim}

% Local Variables:
% TeX-master: "users_guide"
% End:      
