%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Imports, Inheritance, Declarations and Assignments}
\label{inheritanceEtc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#import and \#from directives}
\label{inheritanceEtc.extend}

The \code{\#import} and \code{\#from} directives are used to import Python
modules or stuff from inside modules.  The syntax is identical to the import
syntax in Python.  Imported modules are visible globally to all methods in the
generated Python class.

\begin{verbatim}
#import math
#import math as mathModule
#from math import sin, cos
#from math import sin as _sin
\end{verbatim}

After the above imports, \code{\$math}, \code{\$mathModule}, 
\code{\$sin}, \code{\$cos} and \code{\$\_sin} may be used in 
\code{\$placeholders} and expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#extends}
\label{inheritanceEtc.extends}

The \code{\#extends} directive is used to specify the base classes that the
generated servlet class should inherit from.  It is equivalent to PSP's
\code{``@page extends=''} directive.

\begin{verbatim}
#from Cheetah.Templates.SkeletonPage import SkeletonPage
#extends SkeletonPage
\end{verbatim}

Multiple inheritance is allowed, provided that the first base class is a
subclass of Cheetah.Template.Template:

\begin{verbatim}
#from Cheetah.Templates.SkeletonPage import SkeletonPage
#from MyMixin import MyMixin
#extends SkeletonPage, MyMixin
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#implements}
\label{inheritanceEtc.implements}

The \code{\#implements} directive is used specify the name of the method that a
template implements.  It is equivalent to PSP's \code{@page method=} directive.
The default method is \code{.writebody()}.  If this directive doesn't make sense
to you, you don't need it.

% @@ MO: This still doesn't make any sense to somebody who doesn't use PSP.
% What does it mean for a template to "implement a method"?  A template "has"
% methods, it doesn't "implement" a method.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#set}
\label{inheritanceEtc.set}

\code{\#set} is used to create and update local variables at run time.
\code{\#set \$var = EXPRESSION}. The expression may be any Python expression.
Remember to preface variable names with \$, unless it is part of an
intermediate result in a list comprehension.

Here are some examples:
\begin{verbatim}
#set $size = $length * 1096
#set $buffer = $size + 1096
#set $area = $length * $width
#set $namesList = ['Moe','Larry','Curly']
#set $prettyCountry = $country.replace(' ', '&nbsp;')
\end{verbatim}

\code{\#set} variables are useful to assign a short name to a
\code{\$deeply.nested.value}, to a calculation, or to a printable version of
a value.  The last example above converts any spaces in the 'country' value
into HTML non-breakable-space entities, to ensure the entire value appears on
one line in the web browser.

\code{\#set} variables are also useful in \code{\#if} expressions, but
remember that complex logical routines should be coded in Python, not in
Cheetah!
\begin{verbatim}
#if $size > 1500
  #set $adj = 'large'
#else
  #set $adj = 'small'
#end if
\end{verbatim}

By default, \code{\#set} variables are not visible in method calls or include
files unless you use the \code{global} attribute: \code{\#set global \$var =
EXPRESSION}.  Global variables are visible in all methods, nested templates and
included files.  Use this feature with care to prevent surprises.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#attr}
\label{inheritanceEtc.attr}

The \code{\#attr} directive is used to declare new attributes of the generated Python
class.  It should be used to assign simple Python literals such as numbers or
strings.  

\begin{verbatim}
#attr myAttr = 1234
#attr myAttr2 = 'a string'
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#def}
\label{inheritanceEtc.def}

The \code{\#def} directive is used to declare new methods of the generated Python
class.  It is roughly analogous to Python's \code{def} statement.  Any Cheetah
code in the body of the \code{\#def} will be processed.  

\begin{verbatim}
#def myMeth()
This is the text in my method 
$a $b $c(123)  ## these placeholder names have been defined elsewhere
#end def

## and now use it...
$myMeth()
\end{verbatim}

The arglist and parentheses can be omitted:
\begin{verbatim}
#def myMeth
This is the text in my method 
$a $b $c(123)
#end def

## and now use it...
$myMeth
\end{verbatim}

Methods can accept arguments, and have defaults for those arguments.  Always use the 
\code{\$} before variable names:
\begin{verbatim}
#def myMeth($a, $b=1234)
This is the text in my method 
$a - $b
#end def

## and now use it...
$myMeth(1)
\end{verbatim}

The output from this last example will be:

\begin{verbatim}
This is the text in my method 
1 - 1234
\end{verbatim}

If a method already exists with the same name as the \code{\#def}, it will be replaced
with the new definition.  If the new \code{\#def} occurs in a subclass, it overrides the
parent's definition.  See the \code{\#extends} directive above for information about
subclasses.  Overriding is frequently used for blocks, which will be described next.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#block ... \#end block}
\label{inheritanceEtc.block}

The \code{\#block} directive allows you to mark sections of your template
that can be selectively reimplemented by subclasses of the template.  It is
very useful for selectively changing part of a template without having to
copy-paste-and-edit the entire thing.  The output from a template definition
that uses blocks will be identical to the output from the same template with
the \code{\#block and \#end block} tags removed. 

To reimplement the block, use the \code{\#def} directive.  The magical effect is that it
goes back and changes the output text {\em at the point the original block was
defined} rather than at the location of the reimplementation.

\begin{verbatim}
#block [blockName] 
[block contents] 
#end block [blockName]

#block testBlock
Text in the contents 
area of the block directive
#if $testIt
$getFoo() 
#end if
#end block testBlock
\end{verbatim}

\code{\#block} directives can be nested to any depth.

\begin{verbatim}
#block outerBlock
Outer block contents 

#block innerBlock1
inner block1 contents 
#end block innerBlock1

#block innerBlock2
inner block2 contents 
#end block innerBlock2

#end block outerBlock
\end{verbatim}

Note that the name of the block is optional for the \code{\#end block} tag.

Technically, \code{\#block} directive is equivalent to a \code{\#def} directive
followed immediately by a \code{\#placeholder} for the same name.  In fact,
that's what Cheetah does.  So \code{\#block} creates a method as well as
defining a block, and you may call this method using a placeholder if you want
its output to appear in other locations too.

Sometimes Cheetahites use the term "block" to refer to any multiline directive
(e.g., \code{\#for ... \#end for}).  Thus, the terms "for-blocks", "if-blocks",
etc.  These have nothing to do with the blocks described in this section, which
are methods created by the \code{\#block} directive.  It's just a coincidence
that the English language uses the same term for both things.  (Did you know 
that "run" has over fifty meanings in the dictionary?  And "take" has
seventy-three.  That's not counting phrases like "take off" and "run-in".)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#settings ... \#endSettings}
\label{inheritanceEtc.settings}

[This explanation is preliminary and untested.]

\code{\#settings} provides yet another way to set values for
\code{\#placeholders} to find, using Cheetah's SettingsManager infrastructure.
It is best understood by reading the comments in
\code{\#SettingsManager.py} in conjunction with this documentation.

SettingsManager provides a sophisticated strategy for getting and setting
key/value pairs (called "settings") individually, or in bulk from a dictionary
or a hierarchy of dictionaries.  A "hierarchy of dictionaries" means you can
pass in a dictionary of dictionaries (of dictionaries, etc...) containing only
the keys and subkeys (and subkeys, etc...) that have changed, and
SettingsManager will merge all the changes in.  SettingsManager can also read
settings from an exec'able Python string or file, or from a text string or file in ConfigParser format (aka Windows .ini format).  Cheetah does one up on 
ConfigParser, however, because it parses case-sensitively, and automatically
converts numeric values to numbers, 'None' to None, and 'true' and 'false' to
Boolean true and false.  

What does this have to do with Cheetah?  It means that you can put:

\begin{verbatim}
#settings
test: blarg
#end settings
$test

#settings python
test = 'blarg'
#end settings
$test
\end{verbatim}

in your template and get the following output:

\begin{verbatim}
blarg

blarg
\end{verbatim}

Pretty snazzy, eh?  What's going on here?  Both the first and the second
stanzas above put a key 'test' with the value 'blarg' at the end of the 
searchList.  "At the end" means it is at the bottom of the totem pole,
the last in the pecking order, and will be overridden by any other key
'test' in the searchList, by a \code{\#set} variable 'test', or by an attribute
'test' in the template object.  The first stanza is in ConfigParser format
(aka Windows .ini format)--note the lack of \code{\$} before the key, and the
lack of quotes around the value.  The
second stanza is in Python format, as if it were a Python module, with
quotes, but no \code{\$}.

%% @@MO: Is the first stanza 'test: blarg' or 'test = blarg'.  The former is
%% what ConfigParser accepts (with a [section] header), and the latter is
%% what Tavis' e-mail says.
%% However, when I tried it either way, I got a "NameMapper.NotFound: test"
%% error.

You may also use \code{SettingsManager} in your own applications, by using it
as a base class for your application class.  Then your users can keep their
preferences in configuration files, and you can use the 
\code{SettingsManager} methods to parse the files and extract the settings.

(\code{\#settings} is also meant as a substitute for those who miss the
\code{\#data} directive that existed in Cheetah 0.9.8a3 - 0.9.8 and are not
satisfied with \code{\#attr} and \code{\#def}.)

The following compiler settings affect \code{\#settings}:
'putSettingsInSearchList' (default true).

Dictionary merging can be turned off with the 'nomerge' keyword.

%% @@MSO: Need example of the 'nomerge' keyword.  Where do you specify it?

%% @@MSO: Tavis needs to refine this section, since only he understands how
%% #settings is supposed to work.

% Local Variables:
% TeX-master: "users_guide"
% End:      
