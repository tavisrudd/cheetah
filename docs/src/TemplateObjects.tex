\section{Template Objects}
\label{TSobjects}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Template class}

The Template class (\code{Cheetah.Template.Template}) is the heart of Cheetah.
It parses and compiles Template Definitions into Python code and serves the
filled template output to any client that requests it.  When people say ``the
template'', they mean an instance of the Template class or one of its
subclasses.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Constructing Template Objects}

\begin{description}

\item{\code{templateObj = Template("The king is a \$placeholder1.")}}
     Pass the Template Definition as a string.

\item{\code{templateObj = Template(file="fink.tmpl")}}
     Read the Template Definition from a file named "fink.tmpl".
     
\item{\code{templateObj = Template(file=f)}}
     Read the Template Definition from file-like object 'f'.
     
\item{\code{templateObj = Template("The king is a \$placeholder1.", dic, obj)}}
     Pass the Template Definition as a string.  Also pass two Namespaces for the
     Search List: a dictionary 'dic' and an instance 'obj'.
     
\item{\code{templateObj = Template(None, dic, obj, file="fink.txt")}}
     Same, but pass a filename instead of a string.  The \code{None} is required
     here to represent the missing Template Definition string--this due to
     Python's rules for positional parameters.
     
\item{\code{templateObj = Template(None, dic, obj, file="fink.txt")}}
     Same with a file object.

\end{description}


You must pass either a Template Definition string or a 'file' keyword argument,
but not both.  These invocations all raise a TypeError:

\begin{verbatim}
templateObj = Template() 
templateObj = Template("The king is a $placeholder1", file="fink.txt")
templateObj = Template("The king is a $placeholder1", file=f)
\end{verbatim}

Certain other keyword arguments are also accepted, see 
``Keyword arguments accepted by the constructor'' below.
     
Any positional arguments besides the first are Namespaces for the Search List.
The constructor builds a Search List as a flat list of Namespaces,
concatenated in the following order:

\begin{enumerate}

\item  All the Namespaces passed to the constructor, from left to right.

\item  The TO itself (its \code{self} attribute), 

\item  The Namespaces in the keyword argument \code{searchList} if present.  
     The argument value be a list or a tuple.

\end{enumerate}


Every Namespace must have Namespace Keys and Namespace Values.  This means it
must be an object that supports attribute/value pairs or key/value pairs.  
Instances, dictionaries, modules and classes all make suitable Namespaces.
The Namespace Keys must be strings; the Namespace Values may be any Python
object.

If the Placeholder Name uses Dotted Notation, the Namespace Value will itself
be used as a Namespace recursively to resolve each Identifier from left to 
right.  Each recursive ``Namespace'' must be a valid Namespace type 
{\em or} a Python list or list-compatible instance.  However, the top-level
Namespace Value may {\em not} be a list, because the first Identifier in a
Placeholder Name may not be numeric.  (If this paragraph is unclear, read it
again after you're read the ``Placeholder Tags'' chapter.)

Let's look again at that example in the introduction.  (Get used to it; you'll
be seeing it again later too.)

\begin{verbatim}
>>> from Cheetah.Template import Template
>>> templateDef = """\
... <HTML>
... <HEAD><TITLE>$title</TITLE></HEAD>
... <BODY>
... $contents
... </BODY>
... </HTML>"""
>>> nameSpace = {'title': 'Hello World Example', 'contents': 'Hello World!'}
>>> templateObj = Template(templateDef, nameSpace)
\end{verbatim}

Now let's sneak a peek at this TO's Search List:

\begin{verbatim}
>>> templateObj.searchList()
[{'title': 'Hello World Example', 'contents': 'Hello World!'}, 
<Cheetah.Template.Template instance at 0x80e8464>]
\end{verbatim}

Just as we expected, the Search List contains two elements: our 
\code{nameSpace} dictionary, and the TO's \code{self}.

(Note: the Search List looks like a Python list but it's not.  With few
exceptions, you should not attempt to modify the Search List after the Template
Object has been created.)

Here's another TO which will produce the identical result.  This time, we'll be
lazy and use the default Namespace rather than adding our own.

\begin{verbatim}
>>> nameSpace = {'title': 'Hello World Example', 'contents': 'Hello World!'}
>>> templateObj2 = Template(templateDef)
>>> templateObj2.title = 'Hello World Example'
>>> templateObj2.contents = 'Hello World!'
>>> templateObj2.searchList()
[<Cheetah.Template.Template instance at 0x81a153c>]
\end{verbatim}

Here's a third TO that passes our \code{nameSpace} dictionary
another way.  It also passes Python's \code{\_\_builtin\_\_} module just for
fun.  The \code{\_\_builtin\_\_} module contains all of Python's built-in
functions.  We won't actually use it until we learn how to call functions in
the ``Functions and Macros'' chapter, but it's good to know it's available.

\begin{verbatim}
>>> import __builtin__
>>> mySearchList = (nameSpace, __builtin__)
>>> templateObj3 = Template(templateDef, searchList=mySearchList)
>>> templateObj3.searchList()
[<Cheetah.Template.Template instance at 0x81a5824>, {'title': 'Hello World Example', 'contents': 'Hello World!'}, <module '__builtin__' (built-in)>]
\end{verbatim}

Because the current implementation compiles the TO immediately, your Search 
List must already contain Namespace Values of the appropriate types for all
Placeholder Names, at least those which are not simple strings or are used
in Display Logic (that is, in the attribute of an \code{\#if} or \code{\#for}
directive).  Otherwise you will likely get an exception.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using Template objects}

To use a TO, simply print it, apply Python's
\code{str()} function to it, or call its \code{.respond} method.  This is
called ``filling'' the TO or informally,  ``filling in the template''.  The
result is a string with all the Placeholders filled in with their current
Placeholder Values, and all the directives executed.  The resulting string is
called the Filled Template.

\begin{verbatim}
>>> print templateObj
<HTML>
<HEAD><TITLE>Hello World Example</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
\end{verbatim}

To prove that all three templateObj's produce identical results, we'll run an
equality test on their Filled Templates.  The test will print ``1'' if the
Filled Templates are identical, or ``0'' if they are not.

\begin{verbatim}
>>> str(templateObj) == str(templateObj2) == str(templateObj3)
1
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Modifying Template objects}

From the same TO you can produce as many Filled Templates as you
want, each with its own set of changeable data.  To set the changeable data for
the next Filled Template, simply modify the Namespaces in the Search List.

\begin{verbatim}
>>> nameSpace['contents'] = 'Goodbye, cruel world!'
>>> print templateObj
<HTML>
<HEAD><TITLE>Hello World Example</TITLE></HEAD>
<BODY>
Goodbye, cruel world!
</BODY>
</HTML>
\end{verbatim}

Or for templateObj's 2 and 3:

\begin{verbatim}
>>> templateObj2.contents = 'Goodbye, cruel world!'
>>> str(templateObj) == str(templateObj2) == str(templateObj3)
1
\end{verbatim}

(templateObj3 didn't have to be modified because it's reading the same
\code{nameSpace} dictionary we already modified.)

All the Namespace Values above are strings, but they can actually be any Python
type.  You may even change values from one type to another.  However, if you
change a value from an autocalled type (a function or method) to a
non-autocalled type (any other type) or vice-versa, you must recompile the
TO by calling the \code{.compileTemplate()} method {\em before filling it}.
Otherwise, Cheetah will autocall when it shouldn't or
won't autocall when it should.  For the reason why, see the section
``Autocalling'' in the chapter ``Placeholder Tags''.

% Mention the exact consequences of wrongly autocalling or wrongly not
% autocalling.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Keyword arguments accepted by the constructor}

None of these keyword arguments are necessary for normal usage of a TO.

\begin{description}

\item(file) Discussed above in ``Constructing Template Objects''.

\item{macros} Dictionary of macro name (string) -> macro definition (function).
     These macros are defined before the TO is compiled.

\item{cheetahBlocks} Dictionary of block name (string) -> block definition
     (string).

% Why would a programmer want to call this?

\item{settings}  Dictionary of configuration settings to merge in.  This is
     often useful to specify an alternate behavior for missing Namespace Keys:
\begin{verbatim}
from Cheetah import CodeGenerator
settings = {'varNotFound_handler': CodeGenerator.varNotFound_bigWarning}
templateObj = Template(file="fink.txt", settings=settings)       # Or:
templateObj = Template("The king is a $placeholder1.", settings=settings)
\end{verbatim}
    

\item{overwriteSettings}  Dictionary of configuration settings.  Any existing
     configuration settings are erased.

\item{plugins}  List of Cheetah plugins to register, in addition to those
     specified by the configuration setting `plugins'.  Cheetah ships with two
     plugins so far: a debugger and a PSP interface.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Methods}

None of these methods are necessary for normal usage of a TO.

\begin{description}

\item{.addToSearchList(theNamespace, restart=True)}  Append the given Namespace
     to the Search List.  Leave the optional second argument at its default
     value so that the template gets recompiled.  (This method is of dubious
     value and may be removed.)

\item{.defineTemplateBlock(blockName, blockContents)}  Add a named block to the
template.  Both arguments must be strings.

% What good is it to define a template block?  Does this append the block to
% the Template Definition?  When will the block be visible in the Filled
% Template?

\item{.extendTemplate(extension)}  The docstring just says, ''@@needs
     documenting'').  Presumably, 'extension' is a string.  Used to 
     programmatically create nested documents?

\item(.killTemplateBlock(*blockNames))  Delete the named blocks from the 
Template Definition.  They will no longer show up in Filled Templates.

% I propose we delete .killTemplateBlock.  The #if directive covers all its
% functionality and more.  Also, .killTemplateBlock is destructive in regard to
% future Filled Templates: there's no way to get the block back if you need it
% again later, whereas #if will happily hide and show blocks as appropriate.

\item{.loadMacro, .loadMacros and .loadMacrosFromModule}  See the chapter
     ``Functions and Macros''.

\item{.getFileContents(fileName) -> string}  Returns the contents of the named
     file.  May be overridded to do, e.g., URL retrievals.

\item{.registerServerPlugin(plugin)}  Register a plugin that extends the
     functionality of the Template.  See ``plugins'' in the section on keyword
     arguments.

\item{.runAsMainProgram()}

\item{.searchList()}  Return the Search List.  It's a UserList subclass, so you
     can use Python's standard list operations on it.  If you add or delete
     namespaces, call \code{.compileTemplate()} afterwards to recompile the template
     {\em before trying to fill it}.

\item{.compileTemplate()}  Recompile the template.  

\item{.recompile()}  Synonym for \code{.compileTemplate}.

\item{.translatePath()}  ``A hook to enable proper handling of server-side
     paths with Webware.''
     
\item{.getUnknowns()}  Return a list of Placeholder Names which are missing in
     the Search List.

\end{description}

Since the Template class inherits from the SettingsManager mixin, those methods
are available to change configuration settings after instantiation.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Instance variables}

You shouldn't use or modify these directly, but they are documented here for
completeness.

\begin{description}

\item{._fileName}  The filename that was passed to the constructor's `file'
     keyword argument, or None if a filename was not passed.
     
\item{._fileMtime}  The modify time of the file whose filename was passed to
     the constructor's `file' keyword argument, or None if no filename was
     passed.  (This is for future implementation of automatically recompiling
     the TO if the source file changes.)

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Debugging}

If the environmental variable \code{CHEETAH\_DEBUG} is True, the TO will
run in debug mode.  This provides a more verbose error message if an 
exception occurs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subclasses}

\begin{description}

\item{Cheetah.Servlet.TemplateServlet}  ``An asbstract base class for Cheetah
     servlets that can be used with Webware.''  The constructor is the same
     as the Template class'.  There is an \code{.initializeTemplate()} method
     you can override to do setup before the template is compiled.  This class
     also inherits from \code{WebKit.HTTPServlet.HTTPServlet} if Webware is
     available.  (If not, it fakes it with an empty superclass called
     HTTPServlet to satisfy the inheritance.)

\item{Cheetah.Templates.SkeletonPage}  A TemplateServlet subclass suitable as
     a \code{WebKit.Page}-like superclass for your site.  The Template 
     Definition encompasses an entire HTML page, with blocks for the content,
     page header/footer, sidebars, etc, features for stylesheet dictionaries,
     HEAD tags, BODY attributes, etc.  An example of a site using this is in
     the {\bf examples/webware\_examples/} directory.

\end{description}
