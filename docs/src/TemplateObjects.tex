\section{Template Objects}
\label{TSobjects}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Template class}

The Template class (\code{Cheetah.Template.Template}) is the heart of Cheetah.
It parses and compiles Template Definitions into Python code and serves the
filled template output to any client that requests it.  When people say ``the
template'', they mean an instance of the Template class or one of its
subclasses.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Constructing Template Objects}

Here's the signature for the Template constructor:

\begin{verbatim}
def __init__(self, templateDef, *searchList, **kw):
\end{verbatim}

The constructor has one required argument: the Template Definition as
a string.  Any additional arguments are Namespaces for the Search List.  The
constructor also accepts keyword arguments.

The complete Search List consists of:  all the Namespaces passed to the
constructor, then the template itself (the Template Object's \code{self}
attribute), then the \em{tuple} of Namespaces in the keyword argument
\code{searchList} if present.  All these Namespaces are concatinated in order
into a flat list.  Each Namespace may be any Python object that has attributes,
keys and/or subscripts: this includes instances, dictionaries, modules,
lists, classes, etc.

Let's look again at that example in the introduction.  (Get used to it; you'll
be seeing it again later too.)

\begin{verbatim}
>>> from Cheetah.Template import Template
>>> templateDef = """\
... <HTML>
... <HEAD><TITLE>$title</TITLE></HEAD>
... <BODY>
... $contents
... </BODY>
... </HTML>"""
>>> nameSpace = {'title': 'Hello World Example', 'contents': 'Hello World!'}
>>> templateObj = Template(templateDef, nameSpace)
\end{verbatim}

Now let's sneak a peek at this template's Search List:

\begin{verbatim}
>>> templateObj.searchList()
[{'title': 'Hello World Example', 'contents': 'Hello World!'}, 
<Cheetah.Template.Template instance at 0x80e8464>]
\end{verbatim}

Just as we expected, the Search List contains two elements: our 
\code{nameSpace} dictionary, and the template's \code{self}.

Here's another Template Object which will produce the identical result.
This time, we'll be lazy and use the default Namespace rather than adding our
own.

\begin{verbatim}
>>> nameSpace = {'title': 'Hello World Example', 'contents': 'Hello World!'}
>>> templateObj2 = Template(templateDef)
>>> templateObj2.title = 'Hello World Example'
>>> templateObj2.contents = 'Hello World!'
>>> templateObj2.searchList()
[<Cheetah.Template.Template instance at 0x81a153c>]
\end{verbatim}

Here's a third Template Object that passes our \code{nameSpace} dictionary
another way.  It also passes Python's \code{\_\_builtin\_\_} module just for
fun.  The \code{\_\_builtin\_\_} module contains all of Python's built-in
functions.  We won't actually use it until we learn how to call functions in
the ``Functions and Macros'' chapter, but it's good to know it's there.

\begin{verbatim}
>>> import __builtin__
>>> mySearchList = (nameSpace, __builtin__)
>>> templateObj3 = Template(templateDef, searchList=mySearchList)
>>> templateObj3.searchList()
[<Cheetah.Template.Template instance at 0x81a5824>, {'title': 'Hello World Example', 'contents': 'Hello World!'}, <module '__builtin__' (built-in)>]
\end{verbatim}

(By the way, the reason the 'searchList' keyword argument must be a tuple is
that it's added using Python's \code{.extend} method for list objects, and
the \code{.extend} method requires a tuple.)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using Template objects}

To use a template, simply print it, apply Python's
\code{str()} function to it, or call its \code{.respond} method.  This is
called ``filling in'' or ``invoking'' the template.  The result is a string
with all the placeholders filled in with their current values, and all the
directives executed; the resulting string is called the Filled Template.

\begin{verbatim}
>>> print templateObj
<HTML>
<HEAD><TITLE>Hello World Example</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
\end{verbatim}

To prove that all three templateObj's produce identical results, we'll run an
equality test on their Filled Templates.  The test will print ``1'' if the
Filled Templates are identical, or ``0'' if they are not.

\begin{verbatim}
>>> str(templateObj) == str(templateObj2) == str(templateObj3)
1
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Modifying Template objects}

From the same template instance you can produce as many Filled Templates as you
want, each with its own set of changeable data.  To set the changeable data for
the next template, simply modify the Namespaces in the Search List.

\begin{verbatim}
>>> nameSpace['contents'] = 'Goodbye, cruel world!'
>>> print templateObj
<HTML>
<HEAD><TITLE>Hello World Example</TITLE></HEAD>
<BODY>
Goodbye, cruel world!
</BODY>
</HTML>
\end{verbatim}

Or for templateObj2:

\begin{verbatim}
>>> templateObj2.contents = 'Goodbye, cruel world!'
>>> str(templateObj) == str(templateObj2) == str(templateObj3)
1
\end{verbatim}

templateObj3 didn't have to be modified because it's reading the same
\code{nameSpace} dictionary we already modified.  

All the Namespace values above are strings, but they can actually be any Python
type.  You can even change values from one type to another.  However, if you
change a value from an autocalled type (a function or method) to a
non-autocalled type (any other type) or vice-versa, you must recompile the
template by calling the \code{.startServer()} method before
filling the template.  Otherwise, Cheetah will autocall when it shouldn't or
won't autocall when it should.  For the reason why, see the section
``Autocalling'' in the chapter ``Placeholder Tags''.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Other keyword arguments accepted by the constructor)

\begin{description}

\item{macros} Dictionary of macro name (string) -> macro definition (function).
     These macros are defined before the template is parsed.

\item{cheetahBlocks} Dictionary of block name (string) -> block definition
     (string).

% Of what use is this?

\item{settings}  Dictionary of configuration settings to merge in.

\item{overwriteSettings}  Dictionary of configuration settings.  Any existing
     configuration settings are erased.

\item{plugins}  List of Cheetah plugins to register, in addition to those
     specified by the configuration setting `plugins'.  The two plugins that
     come with Cheetah are a debugger and a PSP interface.

% What are plugins?

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Methods}

None of these methods are necessary for normal usage of a template.

\begin{description)

\item{.addToSearchList(theNamespace, restart=True)}  Append the given Namespace
     to the Search List.  Leave the optional second argument at its default
     value so that the template gets recompiled.

\item{.defineTemplateBlock(blockName, blockContents)}  Add a named block to the
template.  Both arguments must be strings.

% What good is it to define a template block?  Does this append the block to
% the Template Definition?  When will the block be visible in the Filled
% Template?

\item{.extendTemplate(extension)}  The docstring just says, ''@@needs
     documenting'').  Presumably, 'extension' is a string.  Used to 
     programmatically create nested documents?

\item(.killTemplateBlock(*blockNames))  Delete the named blocks from the 
Template Definition.  They will no longer show up in Filled Templates.

% I don't think we need .killTemplateBlock -- it doesn't make much sense in
% Cheetah.  A conditional block is better because it can reappear and
% disappear as desired.

\item{.loadMacro, .loadMacros and .loadMacrosFromModule}  See the chapter
     ``Functions and Macros''.

\item{.getFileContents(fileName) -> string}  Returns the contents of the named
     file.  May be overridded to do, e.g., URL retrievals.

\item{.registerServerPlugin(plugin)}  Register a plugin that extends the
     functionality of the Template.

% Say what?

\item{.runAsMainProgram()}

\item{.searchList()}  Return the Search List.  It's a UserList subclass, so you
     can use Python's standard list operations on it.  If you add or delete
     namespaces, call \code{.startServer()} afterwards to recompile the template
     before trying to fill it.

\item{.startServer()}  Recompile the template.  

\item{.translatePath()}  ``A hook to enable proper handling of server-side
     paths with Webware.''

\end{description}

Since Template uses the SettingsManager mixin, those methods are available to
to change configuration settings after instantiation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Debugging}

If the environmental variable \code{CHEETAH\_DEBUG} is True, the template will
run in debug mode.
