\section{Directive Tags Reference}
\label{directives}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Comment directives}
\label{directives.comments}

Comment directives are used to mark notes, explanations, and decorative text
that should not appear in the output.  There are two forms of the comment
directive: single-line and multi-line.

All text in a Template Definition that lies between 2 hash characters
(\code{\#\#}) and the end of the line is treated as a single-line comment and
will not show up in the output, unless the 2 hash characters are escaped with a
backslash.
\begin{verbatim}
##=============================  this is a decorative comment-bar
$var    ## this is an end-of-line comment
##=============================
\end{verbatim}

Any text between \code{\#*} and \code{*\#} will be treated as a multi-line
comment.
\begin{verbatim}
#*
   Here is some multiline
   comment text
*#
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#raw}
\label{directives.raw}

Any section of a Template Definition that is inside a \code{\#raw} ...
\code{\#end raw} tag pair will be printed verbatim without any parsing of
\$placeholders or other directives.  This can be very useful for debugging, or
writing Cheetah examples and tutorials.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#for ... \#end for}
\label{directives.for}

The \code{\#for} directive iterates through a set of data.

Here's how to create list of numbers separated by hyphens. This ``\#end for''
tag shares the last line to avoid introducing a newline character after each
hyphen.  
\begin{verbatim}
#for $i in range(15)
$i - #end for
\end{verbatim}

The previous example will put an extra hyphen after last number.  Here's how to
get around that problem, using the \code{\#set} directive, which will be dealt
with in more detail below.
\begin{verbatim}
#set $sep = '' 
#for $name in $names 
$sep$name 
#set $sep = ', ' 
#end for 
\end{verbatim}

Here's how to loop through a dictionaries keys and values:
\begin{verbatim}
#for $key, $value in $dict
$key - $value
#end for
\end{verbatim}

Here's how to create a simple client listing:
\begin{verbatim}
<TABLE>
#for $client in $service.clients
<TR>
<TD>$client.surname, $client.firstname</TD>
<TD><A HREF="mailto:$client.email" >$client.email</A></TD>
</TR>
#end for
</TABLE>
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#slurp}
\label{directives.slurp}

The \code{\#slurp} directive comes in handy for {\bf slurping up} extra newline
characters in for loops:
\begin{verbatim}
#for $i in range(15)
$i - #slurp
#end for
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#break and \#continue}
\label{directives.break}

These directives are use as they are used in Python. \code{\#break} will
prematurely exit a \code{\#for} loop, while \code{\#continue} will immediately
jump to the next step in the \code{\#for} loop.

In this example the output list will not contain ``10 - ''. 
\begin{verbatim}
#for $i in range(15)
#if $i == 10
  #continue
#end if
$i - #slurp
#end for
\end{verbatim}

In this example the loop will exit if it finds a name that equals 'Joe':
\begin{verbatim}
#for $name in $names
#if $name == 10
  #break
#end if
$name - #slurp
#end for
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#if ... \#else if ... \#else ... \#end if}
\label{directives.if}

The \code{\#if} directives and its kin are used to display a portion of text
conditionally. \code{\#if} and \code{\#else if} should be followed by a
True/False expression, while \code{\#else} should not.  Any Python valid
expression is allowed.  As in Python, the expression is true unless it evaluates
to 0, '', None, an empty list, or an empty dictionary. \code{\#elif} is accepted
as a synonym for {\#else if}.

Here are some examples:
\begin{verbatim}
#if $size >= 1500
It's big
#else if $size < 1500 and $size > 0 
It's small
#else
It's not there
#end if
\end{verbatim}

\begin{verbatim}
#if $testItem($item)
The item $item.name is OK.
#end if
\end{verbatim}

Here's an example that combines an \code{\#if} tag with a \code{\#for} tag.
\begin{verbatim}
#if $people
<TABLE>
<TR>
<TH>Name</TH>
<TH>Address</TH>
<TH>Phone</TH>
</TR>
#for $p in $people
<TR>
<TD>$p.name</TD>
<TD>$p.address</TD>
<TD>$p.phone</TD>
</TR>
#end for
</TABLE>
#else
<P> Sorry, the search did not find any people. </P>
#end if
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#set}
\label{directives.set}

\code{\#set} allows you to assign a value for a placeholder from inside the
Template Definition.  One use for this is to assign a short alias to what would
otherwise be a long Placeholder Name. 

The syntax is: \code{\#set \$var = EXPRESSION}

The expression may be any Python expression. Remember to preface variable names
with \$, unless it is part of an intermediate result in a list comprehension.

Here are some examples:
\begin{verbatim}
#set $size = $length * 1096
#set $buffer = $size + 1096
#set $area = $length * $width
#set $namesList = ['Mo','Larry','Curly']
#set $sizeSteps = [i*15 for i in range(10)]
\end{verbatim}

It is probably most useful in conjunction with the \code{\#if} directive, but
remember that more complex logical routines should be coded in Python, not in
Cheetah!
\begin{verbatim}
#if $size > 1500
  #set $adj = 'large'
#else
  #set $adj = 'small'
#end if
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#include}
\label{directives.include}

\code{\#include} directives are used to include text from outside the template
definition.  The text can come from \code{\$placeholder} variables or from
external files.  The example below demonstrates use with \code{\$placeholder}
variables.

\begin{verbatim}
#include $myParseText
\end{verbatim}

This example demonstrates its use with external files.
\begin{verbatim}
#include "includeFileName.txt"
\end{verbatim}

By default, included text will be parsed for Cheetah tags.  The argument
{\bf raw} can be used to mark the text for verbatim inclusion without any tag
parsing.

\begin{verbatim}
#include raw $myParseText
#include raw "includeFileName.txt"
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#cache ... \#end cache}
\label{directives.cache}

\code{\#cache} changes the default caching policy for placeholders inside the
directive body.  This affects only Placeholder Tags without their own caching
instruction (i.e., those without a ``*'').

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

$var                ## dynamic - will be reinterpolated for each request
$*var2              ## static - will be interpolated only once at start-up
$*5*var3            ## timed refresh - will be updated every 5 minutes.

#cache
$var                ## static
$*var2              ## static
$*5*var3            ## timed refresh
#end cache

#cache 0.5
$var                ## timed refresh every 30 seconds (0.5 minutes)
$*var2              ## static
$*5*var3            ## timed refresh every 5 minutes
#end cache

</BODY>
</HTML>
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Macros}
\label{directives.macros}


{\bf Macros} allow template designers to define a repeated segment of a Cheetah
syntax.  Their sole purpose is the saving keystrokes and minimizing typographic
errors.  They are simply functions that are called once-off at compile-time to
insert a chunk of Cheetah code to be parsed.  Cheetah's macros are different
from the macro concept in Java's Velocity template engine.

The output from a macro may contain any Cheetah syntax except the \code{\#macro}
directive which is used to define macros (see below).  Macros may insert
placeholders, display logic, other directives, etc.  \$placeholder() functions
may not.  If the output from a \$placeholder() function contains any Cheetah
syntax it will be included without parsing.

A macro is usually defined using the \code{\#macro} directive.  However, it is
possible to write a Python function and register it as a Cheetah macro.
Examples of both are below.  Using the \code{\#macro} directive is more
convenient if your macro consists mostly of text to be inserted with occasional
placeholders.  Loading it from a function is the only choice if you need to do
any calculations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Calling macros}
\label{directives.macros.calling}

To call a macro that has already been defined, use the following syntax:
\code{\#MyMacro(ARGUMENTS)}.  The argument syntax is the same as for
\$placeholder arguments: Python expressions separated by commas with variable
names prefaced with \$.  The ``()'' are required even if there are no arguments.
Unlike other directives, there is no such thing as an explicit tag closure
(\code{\/\#}) for macro calls.

The argument set in a macro call may not contain \$placeholders that have been
defined locally in a \code{\#for} directive, as such \$placeholders are not
available at compile-time.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Defining macros inplace using \#macro}
\label{directives.macros.defining}

An inplace macro definition looks like this:

\begin{verbatim}
#macro <macroName>(<arg set>)
<macro contents>
#end macro

#macro testMacro(a, b)
This is the body of a test macro
$a and $b are interpoloted once-once at compile-time
$otherPlaceholder1 and $otherPlaceholder2 are interpolated for every request
#end macro

#macro tablerows($color)
#for $something in $somelist
    <tr><td bgcolor=$color>$something</td></tr>
#end for
#end macro
\end{verbatim}

When the macro is called, it will insert the body of the macro in the template.
\$placeholders referring to macro arguments are expanded, as are
permanently-cached placeholders.  Dynamic or timed-refresh placeholders are left
as is to be expanded when the template object is filled.  Macros inside macros are
recursively expanded.  Other directives are left alone, to be evaluated when the
template is parsed and compiled.

The formal arguments in a macro definition are defined in regular Python syntax:
The ARE NOT prefaced with \$.  Default values for arguments
may be provided in the usual Python manner.

Here's a large example of a macro definition from the file
{\bf examples/webware\_examples/cheetahSite/SiteTemplate.tmpl}:

\begin{verbatim}
#macro insetBox(width=170, boxTitle='', boxContents='')
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=$width>
  <TR>
    <TD COLSPAN=3 HEIGHT=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
    <TD WIDTH=900 HEIGHT=1 BGCOLOR="$mainTbl.outerFrameColor">#spacer()</TD> ## force full width 
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
    <TD WIDTH=900 HEIGHT=1 BGCOLOR="$mainTbl.innerFrameColor">  ## force full width 
       <DIV CLASS="insetBoxTitleContainer"><DIV CLASS="insetBoxTitle">$boxTitle</DIV></DIV>
    </TD>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
    <TD WIDTH=900 HEIGHT=1 BGCOLOR="$mainTbl.outerFrameColor">#spacer()</TD> ## force full width 
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD COLSPAN=3 HEIGHT=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
</TABLE>
            
<TABLE VALIGN="top" WIDTH=$*width BORDER=0 CELLPADDING=0 CELLSPACING=0>
  <TR>
    <TD WIDTH=1 bgcolor="$*insetBoxes.frameColor">#spacer()</TD>
    <TD WIDTH=900 BGCOLOR="$*insetBoxes.bgcolor">  ## force to full width 
    ## now begin the contents cell of the insetBox
    $boxContents
    ## end insetBox     
    </TD>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.frameColor">#spacer()</TD>
  </TR>
</TABLE>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=$width>
  <TR>
    <TD HEIGHT=1 BGCOLOR="$*insetBoxes.frameColor">#spacer()</TD>
  </TR>
</TABLE>
#end macro
\end{verbatim}

All the formal arguments in the \code{\#insetBox} macro have default values, so
they don't have to be specified when the macro is called.  Notice how the author
uses different \$placeholder styles according to the placeholder.  Most
placeholders have a ``*'' for permanent caching.  Those referring to macro
arguments don't have a ``*'' (that would be silly), as do a few dynamic
placeholders (e.g., \code{\$insetBoxes.titleFrameColor}, which is not defined in
the macro but is assumed to exist when the template is filled.  Notice also how
the author calls macros inside macros (e.g., \code{\#spacer()}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Using existing functions as macros}

Existing functions or object methods may registered as Cheetah macros.  To do
this, execute one of these statements in your Template subclass or inside a
\code{\#data} directive.  

\begin{verbatim}
# Create a macro called 'macroName' that uses 'function'.
self.loadMacro('macroName', function)

# Create macros from functions named 'spacer' and 'formHTMLTag'.  Each macro
# will have the same name as its function.
self.loadMacros(spacer, formHTMLTag)

# Create macros from all the callable objects in module 'Cheetah.Macros.HTML'.
# If the module has the attribute '_exclusionList' the variable names contained
# in the list will not be registered as macros.
self.loadMacrosFromModule(Cheetah.Macros.HTML)
\end{verbatim}

The \code{Template.loadMacrosFromModule()} method is especially useful for
packaging a group of functions as a macro library.  The \code{Cheetah.Macros}
package contains some examples.

Because the functions these macros are loaded from really {\em are} functions,
they can also be loaded into the Search List and used as placeholder functions:

\begin{verbatim}
templateObj = Template(templateDef, Cheetah.Macros.HTML)
\end{verbatim}

There's no confusion here because \code{\$spacer(50)} will get the function and
\code{\#spacer(50)} will get the macro.  Just remember that if the macro outputs
embedded macros, directives or placeholders it cannot be used as a placeholder
function.  Or rather it can, but the embedded \code{\$placeholders} and
\code{\#directives} won't be parsed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\#callMacro(): an extended syntax for calling macros}
\label{directives.macros.callMacro}

The \code{\#macroName(<arg set>)} syntax is great for macros with small strings for
arguments, but it gets messy when you want to feed in larger chunks of text as
arguments.  

For example:
\begin{verbatim}
#macro tableMacro(width, cell1, cell2, cell3)
<TABLE WIDTH=$width>
  <TR>
    <TD>$cell1</TD>
    <TD>$cell2</TD>
    <TD>$cell3</TD>
  </TR>
</TABLE>
#/macro
\end{verbatim}

The cell contents will probably be way to large to use the macro in the normal
fashion: \code{\#tableMacro(200, ``...'', ``...'', ``...'')}.

The \code{\#callMacro()} directive makes it easier to use macros that accept
large chunks of text as arguments.  You would define the macros exactly like
normal macros, but when you call them you could do the following:

\begin{verbatim}
#callMacro tableMacro(width=200)
#arg cell1
sahoeusnthao u
aoesthaothu
aoenthaothu
ashushu
#end arg

#arg cell2
sahoeusnthao u
aoesthaothu
aoenthaothu
ashushu
#end arg

#arg cell3
sahoeusnthao u
aoesthaothu
aoenthaothu
ashushu
#end arg 

#end callMacro

\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Redefinition of macros in subclasses}
\label{directives.macros.redefine}

The \code{Template.loadMacro('macroName', function)} method may be used to
redefine a macro in an extended template.  See sections \ref{directives.extend}
and \ref{directives.extend} for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Macro libraries}
\label{directives.macros.libraries}

Cheetah comes ``batteries included'', with a library of useful macros in the
\code{Cheetah.Macros} package.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#data ... \#end data}
\label{directives.data}

The \code{\#data} directive is a shortcut means of defining variables than be
used by \$placeholders in your template. It's contents can be any valid Python
code.  The code contained in a \#data directive is exec'd in an empty namespace
and that namespace is then merged into the attribute list of the Template
object, which is always part the searchList that \$placeholder values are
extracted from.  Don't preface you variables with \$ inside the data directive!

Here's an example:

\begin{verbatim}
#data
title = "Cheetah - The Python-Powered Template Engine"
siteDomainName = "cheetahtemplate.sourceforge.net"
siteCopyrightName= "The Cheetah Development Team" 
# Python comments can be used
bodyTagAttribs = {"bgcolor": "black",
                  "text":"#000033", 
                  }
navBar = {"bgcolor":"#3366CC", 
          }
locationBar = {"bgcolor":"#3366CC",
               "frameColor":"#CCCCCC",
              }
mainTbl = {"width":"90%",
           "align":"center",
           "contentsBgColor":"white",
           "outerFrameColor":"#6699FF", 
           "innerFrameColor":"#3366CC",
           "innerFrameWidth":8,
           }
#end data
\end{verbatim}

\subsubsection{Dictionary merging}

Dictionaries that are defined in a \code{\#data} directive and already exist as
attributes of the Template object will be merged.  Here's an example:

\begin{verbatim}
from Cheetah.Template import Template

class mySubclass(Template):
    bodyTagAttribs = {"link":"blue"}

templateDef = """
#data 
bodyTagAttribs = {"bgcolor": "black",
                  "text":"#000033", 
                  }
#end data
$bodyTagAttribs
"""
print mySubclass(templateDef)
\end{verbatim}

This will output:
\begin{verbatim}
{'link': 'blue', 'text': '#000033', 'bgcolor': 'black'} 
\end{verbatim}

Dictionary merging can be incredibly useful for selectively changing single
aspects of the cascading style sheet attributes defined by your site-wide
template.  See examples in appendix \ref{examples} for more information on this.

If you want it can be disabled with the \code{nomerge} keyword like this:
\begin{verbatim}
#data nomerge
bodyTagAttribs = {"bgcolor": "black",
                  "text":"#000033", #333333
                  }
#end data
\end{verbatim}

Dictionary merging is recursive.  If a dictionary is contains nested
dictionaries in both the Template object and in the \code{\#data} directive the
entire nested structure will be merged recursively.  You can find more
information on dictionary merging by looking at the source code for
\code{mergeNestedDictionaries} in the \code{Cheetah.Utilities module}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#block ... \#end block}
\label{directives.block}

The \code{\#block} directive allows you to delimit sections of your template
that can be selectively reimplemented by sub-classes of the template.  It is
very useful for selectively changing part of a template without having to
copy-paste-and-edit the entire thing.  The output from a template definition
that uses blocks will be identical to the output from the same template with the 
\code{\#block and \#end block} tags removed. 

\begin{verbatim}
#block [blockName] 
[block contents] 
#end block [blockName]

#block testBlock
Text in the contents 
area of the block directive
#if $testIt
$getFoo() 
#end if
#end block testBlock
\end{verbatim}

\code{\#block} directives can be nested to any depth.

\begin{verbatim}
#block outerBlock
Outer block contents 

#block innerBlock1
inner block1 contents 
#end block innerBlock1

#block innerBlock2
inner block2 contents 
#end block innerBlock2

#end block outerBlock
\end{verbatim}

The implementation of \#block is quite simple.  Each block is the template
definition is replaced with \code{\#include \$cheetahBlocks.<blockName>} and it's
contents are stored in the dictionary Template._cheetahBlocks using the
'blockName' as the dictionary key.  To {\bf redefine} the contents of a block
Cheetah just replaces the blockName's entry in Template._cheetahBlocks.  The
Template class' \code{redefineBlock(blockName, contents)} or
\code{killBlock(blockName)} methods provide a easy way to redefine blocks.

Appendix \ref{examples} contains extended examples of how blocks can be used to
simplify the creation and maintenance of large websites.

Blocks are powerful and unique feature of Cheetah!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#redefine ... \#end redefine}
\label{directives.redefine}

When working with a large number of blocks it can be useful to write all the
redefinitions in one {\bf template extension} string and just feed this string
to the \code{Template.extendTemplate(extensionStr)} method at startup rather
than individually \code{Template.redefineBlock()} for each and every block.

\begin{verbatim}
#redefine [blockName]
[new contents]
#end redefine [blockName]

#redefine footer
<HR>
<P>$copyrightNotice<P>
<div align="center">$companyName<BR>
$address. Phone: $phone, Fax: $fax. Email: $email</div>
#end redefine footer
\end{verbatim}

\code{\#redefine} directives may not be nested.  However, the new contents of
the \code{\#redefine} directives may contain other \code{\#blocks}, even nested
ones, and any other Cheetah syntax, except \code{\#data}, \code{\#macro}, and
\code{\#extend}. Extension strings fed to
\code{Template.extendTemplate(extensionStr)} may also contain \code{\#data} and
\code{\#macro} directives at the top-level, that is outside the
\code{\#redefine} directives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#extend}
\label{directives.extend}

The \code{\#extend} directive is a wrapper around
\code{Template.extendTemplate(extensionStr)} that is used with .tmpl and Webware
(see section \ref{webware} for more). If your .tmpl file contains needs to
\code{\#redefine} blocks and \code{\#data} from a parent Template, rather than
define a new top-level template use this directive to specify the Python module
or .tmpl file that contains the parent Template. 

\code{\#extend <parentTemplateModule>}

Appendix \ref{examples} contains extended examples of how \code{\#extend} is
used.


