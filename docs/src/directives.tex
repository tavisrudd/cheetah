\section{Directive Tags}

{\em Readers: this chapter is {\bf UNTESTED}.  There may be mistakes below, and
there may be more details about the Directives which should be added.  Read the
comments in the source of this chapter (docs/src/directives.tex) to see which
points are still uncertain or what will probably be added after it's verified.}

Directives Tags (\#D's) are used for all functionality that cannot be handled
with simple placeholders.  All directives begin with \code{\#}, and end with
\code{/\#} or the end of the line.

Cheetah does not use HTML/XML-style tags as they are hard to 
distinguish in a file containing real HTML/XML tags.  In addition, Cheetah tags
show up on screen when the Template Definition is viewed in a web browser,
which aids debugging.  HTML-style tags would be invisible.

Some tags have additional words after the
command name.  (These words are called ``arguments'', but don't confuse them
with function arguments and macro arguments, which are different things.)

Some Directives consist of a single tag, while others have a matching end tag
that looks like this: \code{\#end theDirective/\#}.  The text between a tag and
its matching end tag is called the {\em body} of the tag or a {\em block}.  Note
that the body does not include any part of either tag: it's the text
{\em outside} the tags.  However, a directive body may have other directives
inside it.

To escape something that looks like a \#D so that Cheetah will treat it as
ordinary text, place a backslash before the initial \code{\#} (e.g.
$\backslash$\#raw).

Examples:

\begin{verbatim}
#block MyBlock /#
Text in the contents area of the
block directive
#end block /#
\end{verbatim}
or
\begin{verbatim}
#block MyBlock2
Text in the contents area of the
block directive
#end block
\end{verbatim}

\subsection{Whitespace handling}
%% @@ TR: This is an important topic and needs a section of its own.  We need to
%% provide examples and refer to the #slurp directive

%If there is nothing on a line except Directive(s) and whitespace, the line is
%not included in the output.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Comment directives}

Comment directives are used to mark notes, explanations, and decorative text
that should not appear in the output.  There are two forms of the comment
directive: single-line and multi-line.

All text in a Template Definition that lies between 2 hash characters
(\code{\#\#}) and the end of the line is treated as a single-line comment and
will not show up in the output, unless the 2 hash characters are escaped with a
backslash.
\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
##====================================  a decorative comment
$contents                               ## an end-of-line comment
##====================================
</BODY>
</HTML>
\end{verbatim}

Any text between \code{\#*} and \code{*\#} will be treated as a multi-line
comment.
\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
#*
   Here is some multiline
   comment text
*#
##====================================  a decorative comment
$contents                               ## an end-of-line comment
##====================================
</BODY>
</HTML>
\end{verbatim}

% What about "#comment ... #end comment"?  Was it rejected?
% @@ TR: yep

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#block ... \#end block}

\code{\#block} assigns a name to the portion of the TD that is the body of the
directive.   The result is a {\em named block}.  One argument is required: the
block name.  It must follow
the same naming rules as an Identifier.

A named block will appear in the output as if it were ordinary text, but a
later \code{\#redefine} directive can override it.  This replaces the content of
the block with something else at the location where the original block was
defined.  In other words, the original block serves to show where the
\code{\#redefine}'d text should go, and to be a fallback to display if there is
no \code{\#redefine}.  \code{\#redefine} also requires one argument, again the
block name.

A frequent use of \code{\#block} and \code{\#redefine} is to combine a pair of
templates, one a general site framework with the common header and footer, and
the second providing the specific page content.  The general template has a
block called ``pageContent'' with some filler text like, "This page is under
construction."  The specific template mostly consists of one huge
\code{\#redefine}.  (examples/webware\_examples/hello\_world.py shows how to
extend one template with another.)

% Is it possible to retrieve the block's content using $theBlockName?
%% @@TR: yep

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#cache ... \#end cache}

\code{\#cache} changes the default caching policy for placeholders inside the
directive body.  This affects only Placeholder Tags without their own caching
instruction (i.e., those without a ``*'').

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

\$var                ## dynamic - will be reinterpolated for each request
\$*var2              ## static - will be interpolated only once at start-up
\$*5*var3            ## timed refresh - will be updated every 5 minutes.

#cache
\$var                ## static
\$*var2              ## static
\$*5*var3            ## timed refresh
#end cache

#cache 0.5
\$var                ## timed refresh every 30 seconds (0.5 minutes)
\$*var2              ## static
\$*5*var3            ## timed refresh every 5 minutes
#end cache


</BODY>
</HTML>
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#data ... \#end data}

\code{\#data} lets you include Python code directly in your Template 
Definition.  The code is in full Python syntax.  It is run in the namespace of
the Template Object (that is, its \code{self} attribute).  Since the Template
Object is always a Namespace in the Search List, any variable assignments in a
\code{\#data} section may be referred to in Placeholder Tags!

You must use Python variable names inside a \code{\#data} section--you may not
use placeholders.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#extend}

\code{\#extend} is related to but separate from 
\code{.extendTemplate(newTemplateDef)}.  More documentation to come later.

Essentially, \code{\#extend parentTemplateClass} allows you to inherit from
a more general template definition.  You may then \code{\#redefine} some of its
named blocks.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#for ... \#end for}

\code{\#for} is one of two display logic Directives Cheetah has (the other is
\code{\#if}).  \code{\#for} works like in Python: it loops over the Directive
body, each time setting a placeholder to the next element in a list, from first
to last.  Each iteration appends text to the output and executes any
Directives encountered.  If the list is empty, the loop is not run at all.

The syntax of the opening tag is: \code{\#for \$lvaluePlaceholder in
EXPRESSION}.  The \code{\$lvaluePlaceholder} is created in a special namespace
that is searched before the Search List.  EXPRESSION is usually a 
Placeholder Tag that evaluates to a list, but it can be any expression that
returns a list.  As always in Template Definition expressions, you must use
Placeholder Tags instead of variable names.

There are no 'break' or 'continue' Directives in Cheetah.  A \code{\#for} loop
always goes through every element in the list once.  You should have set up the
list in Python code so that it has exactly the elements you wish to loop through
now.

%%@@TR: we should add break and continue in

One trick is to make EXPRESSION a list of instances or a list of dictionaries,
and then use Uniform Dotted Notation to access the object's attributes or keys.
See the example in the \code{\#if} section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\#if ... \#else if ... \#else ... \#end if}

\code{\#if} is one of two display-logic Directives Cheetah has (the other is
\code{\#for}).  Its use is just like in any programming language: to display
a portion of text if some condition is true.  
\code{\#if}, \code{\#else if} and \code{\#else} all have one required argument:
a boolean expression.  Any Python expression is allowed, including operators.
However, your expression may not use variables:  use Placeholder Tags instead.
As in Python, the expression is true unless it evaluates to zero, '', None, an
empty list, or an empty dictionary.

\code{\#elif} is accepted as a synonym for {\#else if}.

Here's an example that combines an \code{\#if} tag with a \code{\#for} tag.

\begin{verbatim}
#if $people
<TABLE>
<TR>
<TH>Name</TH>
<TH>Address</TH>
<TH>Phone</TH>
</TR>
#for $p in $people
<TR>
<TD>$p.name</TD>
<TD>$p.address</TD>
<TD>$p.phone</TD>
</TR>
#end for
</TABLE>
#else
<P> Sorry, the search did not find any people. </P>
#end if
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#include}

\code{\#include} directives are used to include text from outside the template
definition.  The text can come from \code{\$placeholder} variables or from
external files.  The example below demonstrates use with \code{\$placeholder}
variables.

\begin{verbatim}
#include $myParseText
\end{verbatim}

This example demonstrates its use with external files.
\begin{verbatim}
#include "includeFileName.txt"
\end{verbatim}

By default, included text will be parsed for Cheetah tags.  The argument
{\bf raw} can be used to mark the text for verbatim inclusion without any tag
parsing.

\begin{verbatim}
#include raw $myParseText
#include raw "includeFileName.txt"
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#raw}

Any section of a Template Definition that is inside a \code{\#raw} ...
\code{\#end raw} tag pair will be printed verbatim without any parsing of
\$placeholders or other directives.  This can be very useful for debugging, or
writing Cheetah examples and tutorials.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#redefine ... \#end redefine}

%% @@TR: this definitely needs explanation by itself

%See \code{\#block}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#set}

\code{\#set} allows you to assign a value for a placeholder from inside the
Template Definition.  One use for this is to assign a short alias to what would
otherwise be a long Placeholder Name. 

The syntax is: \code{\#set \$lvaluePlaceholder = EXPRESSION}

The expression may be any Python expression. but you must use Placeholder Tags
instead of variable names within it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\#slurp}

\code{\#slurp} has a simple little job: it eats the whitespace and end-of-line
character from the current line so that they will not appear in the output.
Instead, the following line will be joined onto this one.


