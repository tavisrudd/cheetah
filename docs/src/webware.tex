%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using Cheetah with Webware}
\label{webware}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Background}
\label{webware.background}

{\bf Webware} is a 'Python-Powered Internet Platform' that uses servlets in a
manner similar to Java servlets.  {\bf WebKit} is the name of Webware's
application server.  For more details please visit
\url{http://webware.sourceforge.net}.

As Cheetah's core is flexible there are many ways to use it with Webware
servlets.  There are two broad categories: the {\bf Inheritance} approach and the
{\bf Containment} approach.  In the Inheritance approach a servlet is created that
subclasses both the \code{Template} class and Webware's \code{HTTPServlet}
class.  The Template object {\em IS} the servlet and its \code{.respond()} method is
automatically called by WebKit for each request.  All pre-request processing is
handled via Cheetah.

In the Containment approach an instance of the Template class is contained
inside of a Webware servlet.  The servlet must explicitly call the Template
object's \code{.respond()}, or \code{.\_\_str\_\_()}, method for each request.  In
this case the servlet class can handle whatever per-request processing needs to
be done before it calls Cheetah.respond().

The Inheritance approach is the simplest and is best suited for building sites
from scratch. The Containment approach is slightly more complex and is best
suited for use with existing Webware servlets.  It is also ideal for cases where
you wish to use Cheetah for only a portion of the servlet's output, such as a
discussion-forum table at the bottom of a webpage.

There are two ways to use the Inheritance approach: automatically by creating
{\bf \code{.tmpl servlet files}} (e.g. ``myTemplate.tmpl'') or manually by
creating {\bf \code{.py servlet files}} (e.g. ``myServlet.py''). \code{.py
  servlet files} are Webware's default type of servlet file.  A \code{.tmpl
  servlet file} is a Cheetah specific type of servlet file that is converted
automatically into a \code{.py servlet file} that Webware understands.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using .tmpl servlet files}
\label{webware.tmpl}

As mentioned above a \code{.tmpl servlet file} is a Cheetah specific type of
servlet file that is converted automatically, or semi-automatically, into a
\code{.py servlet file} that Webware understands.  Working with \code{.tmpl
  servlet files} hides alot of extraneous details and is recommended for Cheetah
users who don't have a deep understanding of Python.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Converting .tmpl files into .py files}
\label{webware.tmpl.converting}

There are two ways to convert \code{.tmpl servlet files} into \code{.py servlet
  files}.  You can let Cheetah's Webware plugin do it automatically when a
\code{.tmpl servlet file} is requested by a browser. Or you can generate the
\code{.py servlet files} using \code{cheetah-compile}, a small script that is
installed with Cheetah.

Cheetah's Webware plugin is being re-designed at the moment.  The redesign will
be complete for the 0.9.9 release.  Until then use the \code{cheetah-compile}
script.

\code{cheetah-compile} parses the template definitions written in files with the
.tmpl extension and generates a \code{.py servlet file} for each \code{.tmpl
  servlet file}.  On Unix systems, it is installed into a system directory like
\code{/usr/local/bin}, so you can use it without specifying the absolute path of
the script.  On Windows systems, you need to specify the full path
(\code{<cheetahRoot>/bin/cheetah-compile}). Type ``\code{cheetah-compile}'' from the
command line after installing Cheetah to get usage information.  The most common
usage is ``\code{cheetah-compile -R .}'', which will convert all the \code{.tmpl
  servlet file} in the current directory and its subdirectories.

\code{cheetah-compile} overwrites \code{.py servlet files} with the same
basename as \code{.tmpl servlet files} in a directory. For this reason, you
should make changes to the \code{.tmpl} version of the template rather than the
\code{.py} version.  Any \code{.py servlet files} that are about to be
overwritten will are automatically backed up with the extension \code{.py\_bak}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Writing .tmpl servlet files}
\label{webware.tmpl.writing}

Here's an example \code{.tmpl servlet file} with no Cheetah syntax in it:

\begin{verbatim}
## FILE: hello_world.tmpl ##
<HTML>
<HEAD><TITLE>Hello World - Test Servlet</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
\end{verbatim}

Here's the previous example with some Cheetah syntax.  Note that all lines that begin with
\code{\#\#} are comment lines.

\begin{verbatim}
## FILE: hello_world.tmpl ##
##===================================
#data
title = 'Hello World - Test Servlet'
def contents():
    return 'Hello World!'
#end data
##===================================
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
$contents
</BODY>
</HTML>
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using .py servlet files}
\label{webware.py}

When you manually create your Webware \code{.py servlet files} you need to
include some boiler-plate code that is handled automatically in \code{.tmpl
  servlet files}. Specifically, you need to create a Python class that inherits
from Cheetah.Servlet, or a subclass, as in the trivial example below.

\begin{verbatim}
## FILE: hello_world.py ##
template = """
<HTML>
<HEAD><TITLE>'Hello World - Test Servlet</TITLE></HEAD>
<BODY>
Hello World!
</BODY>
</HTML>
"""
from Cheetah.Servlet import TemplateServlet
class hello_world(TemplateServlet):
    def __init__(self):
        TemplateServlet.__init__(self, template) 
\end{verbatim}

TemplateServlet's constructor method (\code{TemplateServlet.\_\_init\_\_()}) adds
the attribute dictionary of the servlet to the searchList that
\code{\$placeholder} variables can extracted from.  Thus, attributes and methods
of the servlet object can be interpolated into the template like this:

\begin{verbatim}
## FILE: hello_world.py ##
template = """
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
$contents
</BODY>
</HTML>
"""
from Cheetah.Servlet import TemplateServlet
class hello_world(TemplateServlet):
    title = 'Hello World - Test Servlet'
    def __init__(self):
        TemplateServlet.__init__(self, template) 

    def contents(self):
        return 'Hello World!'
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The SkeletonPage framework}
\label{webware.skeletonPage}

Sect \ref{libraries.templates.skeletonPage} contains information on a stock
template that greatly simplifies defining the basic HTML structure of your web
page templates.  It is equivalent to Webware's \code{WebKit.Page} servlet and
is well worth the time spent learning how to use it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using the Containment approach}
\label{webware.containment}

With the containment approach your template obj does not repond directly to a
request from Webware's AppServer. Rather, you use a non-Cheetah-specific servlet
to handle the request and use one or more Cheetah template objects inside the
servlet's \code{.respond()} method and send their output via the 
\code{response.write()} method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Using \#include with the containment approach}
\label{webware.containment.includes}

Webware's ``\code{current working directory}'' probably isn't the directory that
your servlet files are sitting in.  All relative paths need to be adjusted so
they are relative to the servlet's directory and not Webware's \code{current
  working directory}.  Webware uses the \code{Servlet.serverSidePath()} method
for this purpose.

The \code{TemplateServlet} class of the inheritance approach does the adjusment
automatically for all relative paths fed to \code{\#include} directive.  When
using the containment approach you need to take a few extra steps to make
\code{\#include} directives work properly with relative paths. First, you need
to map \code{<yourTemplateObj>.normalizePath} to
\code{<yourServletObj>.serverSidePath}. Second, you need to make sure that
\code{<yourTemplateObj>} is compiled by your servlet's \code{awake()} method or
its \code{respond()} method as \code{.serverSidePath()} only works during
Webware's \code{awake-response-sleep} cycle.  It cannot be compiled by you
servlet's \code{__init__()} method as \code{Servlet.serverSidePath()} doesn't
work there.  Also note that due to a bug in Webware your servlet class must
inherit from \code{WebKit.Page} rather than just \code{WebKit.HTTPServlet} for
\code{.serverSidePath()} to work.

\begin{verbatim}
<yourServlet>.__init__():
    # ... after setting up your 'templateDef' and 'nameSpace'
    self.T = Template(templateDef, nameSpace, settings={'delayedCompile':1})
    self.T.normalizePath = self.serverSidePath
    self._templateCompiled = 0

<yourServlet>.awake(trans):
    <yourServlet's BaseClass>.awake(trans)
    if not self._templateCompiled
        self.T.compileTemplate()
        self._templateCompiled = 1

<yourServlet>.respond(trans):
    if not self._templateCompiled
        self.T.compileTemplate()
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User interaction in either approach}
\label{webware.userInteraction}

By {\bf user interaction} we mean the use of forms, query strings or sessions to
create interactive pages that allow user interation with a website.
[{\bf This section is under construction. Check back later.}]



% Local Variables:
% TeX-master: "users_guide"
% End:      
