%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Placeholder Tags (and Values)}

Cheetah's Placeholder Tags are equivalent to data fields in a form letter, or to
\code{\%(key)s} fields in the \code{\%} operator's format string.
In other words, Placeholder Tags are used as lookup keys, and are replaced by
their corresponding values when the template is filled in.
Let's look again at the example from the introduction:

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
$contents
</BODY>
</HTML>
\end{verbatim}

When this template is filled in, the Placeholders \code{\$title} and
\code{\$content} will be replaced with the values for \code{title}
and \code{content}.  Where are the values found?  They are looked up in the
Search List, but more on that later.

Although these values are strings, they could be any type.  Cheetah
converts all values to strings via Python's \code{str()} function before it
inserts the value in the Filled Template.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Anatomy of a Placeholder Tag}

Before getting into the rules, let's look at a few Placeholder Tags to get a
feel for them.

\code{\$a}, \code{\$\_}, \code{\$var}, \code{\$\_var}, \code{\$var1},
\code{\$\_1var}, \code{\$var2\_}, \code{\$dict.key}, \code{\$list.item},
\code{\$*object.method},
\code{\$\{*20*a.b1.c('A', 1, \$federico + 1).d['-']\}},
\code{\$nester(\$nesting(\$nested))}.

% These names are not valid: \code{\$1},
% \code{\$var@2},
% \code{\$\^var}.

A Placeholder Tag consists of: 

\begin{enumerate}
\item  a dollar sign (\code{\$})
\item  an optional opening brace (\code{\{})
\item  an optional caching instruction (\code{*}, or a number between two 
     \code{*}'s)
\item  a Placeholder Name
\item  a closing brace (\code{\}}), if there was an opening brace
\end{enumerate}

As the above examples show, Placeholder Names are similar to Python
expressions in the following ways:

\begin{itemize}

\item  They consist of one or more Identifiers separated by periods.  Each
     Identifier follows the same rules as a Python variable name or attribute
     name: it must start with a letter or an underscore, and the subsequent
     characters must be letters, numbers or underscores.  Identifiers are
     case-sensitive: \code{\$var} is different from \code{\$Var}.

\item  An Identifier may be followed by one or more sets of function arguments
     enclosed in ``()'' and/or key/subscript arguments in ``[]''.

\item  String literals inside argument sets must be quoted, just like in
     Python.  All Python quoting styles are allowed:  \code{'string'},
     \code{"string\n"}, \code{"""string"""}, \code{r'''string'''}.  (However,
     two bugs currently exist: Cheetah misparses \code{'Fred\'s'}, and Python's
     \code{tokenize} module misparses triple-quoted strings with embedded
     newlines.)

\end{itemize}

Placeholder Names differ from Python expressions in the following ways:

\begin{itemize}

\item  You cannot have bare variable names inside argument sets.  Instead of a
     variable name, use a Placeholder Tag.  (Yes, this means putting a
     Placeholder Tag inside a Placeholder Tag.)

\item  Operators are allowed only inside argument sets, and even there should
     be used sparingly.  This applies to the arithmetic operators (+-*/), the
     the logical operators (<, ==), etc.  You should be doing most calculations
     in Python code, not inside your templates.

\end{itemize}

If you use the optional ``{}'' around your Placeholder Names, Cheetah knows
exactly where the Placeholder Names begin and end.  If you don't, Cheetah ends
the Placeholder Name at the first character which cannot legally be a part of
it.  Complex cases may confuse Cheetah (or the human maintainer!), so when in
doubt, use the``{}''.

Cheetah knows that a dollar amount is not a Placeholder Tag, because
Placeholder Names may not begin with a digit or a hyphen.  Thus, Cheetah will
output dollar amounts literally, as it should.  Examples:
\code{\$2.50} and \code{\$-1,234.56} (or \code{\$2,50} and \code{\$-1.234,56}
for Europeans).

To escape other words that look like Placeholder Tags but aren't, put a 
backslash before the dollar sign: (\code{$\backslash$\$variable}).  Cheetah
will output it literally.  This is useful if your document contains examples of
Perl code, because Perl variables look like Cheetah Placeholders.

If a trailing period is found (that is, a period not followed by a valid
Identifier character), Cheetah knows the \$P ends before the
period.  This is useful for \$P's at the end of a sentance.  Likewise, because
punctuation and quotes cannot occur inside a Placeholder Tag (except inside
argument sets), Placeholder Tags may be placed directly before punctuation or
quotes.

     

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Uniform Dotted Notation}

Cheetah uses what we call Uniform Dotted Notation.  This means that in
\code{\$a.b}, 'b' is not necessarily an attribute of 'a'.  'a' may be a
dictionary and 'b' one of its keys.  Thus, the template maintainer does not have
to worry about whether a value is an instance or a dictionary: they can use the
same notation in either case.  The programmer can change the implementation
from one to the other without having to get the Template Definitions changed.

To use Uniform Dotted Notation with dictionaries, the key must be a legal
Identifier.  That is, it must start with a letter or an underscore, and contain
only letters, digits and/or underscores.  If the key does not fit this
limitation, you must use the \code{\$a['key lookup syntax']} instead.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Autocalling}

If the value of an Identifier is a function or a method and no ``()'' are
present, Cheetah will call it without arguments.  This is \em{autocalling}.
The purpose of autocalling is to allow the programmer to change a ``dumb
object'' (a string or number) into a ``smart object'' (a function or method
returning a string or number), or vice-versa, without the template maintainer
having to worry which objects are functions today and which are not.

In \code{\$a.b}, if 'a' is a function or a method, it must return an object
with attributes or keys, and 'b' is looked up in that object.  If 'b'
itself is a function or method, it will also be called, and the final result
will be whatever 'b' returns.

Only functions and methods are autocalled.  Other callable types--in particular
classes and instances--are never autocalled.  Calling a class or instance may
have desirable or undesirable side effects: Cheetah doesn't know!  So if you 
want to call a class or instance or another type, you must use ``()''.

Of course, if you want to pass arguments to a function or method, you have to
use ``()'' also.

If you don't like autocalling, there's a Setting to disable it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Calculating Placeholder Values}

A detailed explanation of how Cheetah looks up and converts Placeholder Values
would be complicated and tedious, but a few points are worth mentioning.

To resolve a Placeholder Name, Cheetah looks up the first Identifier in the
first Namespace in the Search List.  If the Placeholder Key (which may be an
attribute or a key--Cheetah checks both) is not found, Cheetah tries the 
second Namespace, and so on.

Assuming a Namespace Key is found that's identical to the Identifier, the
Namespace Value is taken.  Function calling, autocalling, key/subscript
lookup and Uniform Dotted Notation lookup are performed as appropriate.  (Note
that for all Identifiers except the first, any lookups are performed only in
the preceding value, not in the Search List.)  Finally, Python's \code{str()}
function is called to convert the result to a string, and it's inserted into
the Filled Template.

This process actually happens in two phases.  When the TO is created, and again
whenever its \code{.recompile()} method is called, Cheetah creates a little
Python program and stores it in the TO.  (This is called ``compiling the 
template''.)  The program calculates the Filled Template according to the
specification in the Template Definition.  Each Placeholder Tag is converted
into a Python expression that looks up the value in it's current (at compile
time) position in the Search List.

This has some consequences for how much freedom you have to change a 
Namespace Value's type, whether you can move it from one Namespace to 
another, and whether you can add/delete/move Namespaces in the Search List.
For best results, process your TO in this order:

\begin{enumerate}

\item   Create your Namespaces and assign values for each of your placeholders.

\item   Create the TO, passing it the Template Definition and the Namespaces in
     order.

\item   Fill the template.

\item  If you want to produce another Filled Template, assign new values for
     your placeholders in place.  That is, use ordinary attribute assignment and
     key assignment.  Do not move the attribute/key from one Namespace to 
     another.  Do not change the type of the value.  Do not add a Namespace--
     you should have already passed all the Namespaces you need to the
     constructor.  When you've finished setting your new values, fill the
     template again.  Repeat for as many Filled Templates as you need.

\end{enumerate}

In practice, the rules aren't quite that restrictive.  However, following these
steps is a good habit to get into.  The reason is that when Cheetah compiles
the template, it hardcodes certain assumptions about the Placeholder Values into
the Python code, namely, where each key is in the Search List, and which 
Identifiers are to be autocalled.  Take \code{\$a.b} for example.  Say 'a'
is found in the second Namespace, that Namespace is an instance, and 'a' is a
dictionary.  Cheetah might compile this Placeholder Name to:

\begin{verbatim}
searchList[1].a['b']
\end{verbatim}

Now take \code{\$c.d}.  In this case, 'c' is found in the first Namespace, that
Namespace is a dictionary, and 'c' is a function returning an instance.
Cheetah might compile this Placeholder Name to:

\begin{verbatim}
searchList[0]['c']().d
\end{verbatim}

Now say you add a key 'a' in the first Namespace.  The expression is still
going to the second Namespace, so the new 'a' is ignored.  Now say you change
the type of 'c' from a function returning an instance to an instance itself.
Cheetah will still try to autocall 'c', which will raise a ``not callable''
error.  Now say you change the type of 'a' from dictionary to instance
(or integer!).  You fill the template--and get an AttributeError!

Simple things like changing a string to a number are safe.  But beware of
changing an autocallable value to a non-autocallable one or vice-versa, or
changing an instance to a dictionary.  

However, there is a way to do ``unsafe'' changes without getting bitten.  After
making your changes, recompile the template by calling the TO's
\code{.recompile()} method after making your changes and before filling the
template.  The TO will adjust itself to the new values.

But usually, when you think you want to add a Namespace or change the type
of a value, it's time to create another TO.

Templates can be nested.  A Namespace Value may be another TO.  When your TO
is filled, the inner TO will automatically be filled, and any TO's \em{it}
contains will also be filled, ad infinitum.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Missing values}

If there is no value defined in the Search List for a placeholder name,
Cheetah will search for an leading underscore version of the name.  For
example, if it can't find \code{\$varName} it will attempt to find
\code{\$\_varName}.  If that fails, Cheetah will include the placeholder
tag verbatim in the filled template output.

This behaviour can be customized and a default value can be set for names
that are not found. See section \ref{customizing} for more details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Caching}

By default the value of each \code{\$placeholder} is updated for each request.
If you want to statically cache the value of the \code{\$placeholder} upon
startup, add an asterisk after the \$ sign.  \code{\$var} becomes \code{\$*var}.
See the section on the \code{\#cache} directive below for more information.

If you only need to update the value of the \code{\$placeholders} at specific time intervals use
this form: \code{\$variable} becomes \code{\$*15*variable} , where 15 is the time interval in
minutes.  The time interval can also be specified in fractions of a minute such
as \code{\$*0.5*variable}.

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

$var                ## dynamic - will be reinterpolated for each request
$*var2              ## static - will be interpolated only once at start-up
$*5*var3            ## timed refresh - will be updated every 5 minutes.

</BODY>
</HTML>
\end{verbatim}


