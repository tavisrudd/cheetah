%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Placeholder Tags (and Values)}

Cheetah's Placeholder Tags are equivalent to data fields in a form letter, or to
\code{\%(key)s} fields in the \code{\%} operator's format string.
In other words, Placeholder Tags are used as lookup keys, and are replaced by
their corresponding values when the template is filled in.
Let's look again at the example from the introduction:

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
$contents
</BODY>
</HTML>
\end{verbatim}

When this template is filled in, the Placeholders \code{\$title} and
\code{\$content} will be replaced with the values for \code{title}
and \code{content}.  Where are the values found?  They are looked up in the
Search List, but more on that later.

Although these values are strings, they could be any type.  Cheetah
converts all values to strings via Python's \code{str()} function before it
inserts the value in the Filled Template.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Anatomy of a Placeholder Tag}

Before getting into the rules, let's look at a few Placeholder Tags to get a
feel for them.

\code{\$a}, \code{\$\_}, \code{\$var}, \code{\$\_var}, \code{\$var1},
\code{\$\_1var}, \code{\$var2\_}, \code{\$dict.key}, \code{\$list.item},
\code{\$*object.method},
\code{\$\{*20*a.b1.c('A', 1, \$federico + 1).d['-']\}},
\code{\$nester(\$nesting(\$nested))}.

% These names are not valid: \code{\$1},
% \code{\$var@2},
% \code{\$\^var}.

A Placeholder Tag consists of: 

\begin{enumerate}
\item  a dollar sign (\code{\$})
\item  an optional opening brace (\code{\{})
\item  an optional caching instruction (\code{*}, or a number between two 
     \code{*}'s)
\item  a Placeholder Name
\item  a closing brace (\code{\}}), if there was an opening brace
\end{enumerate}

As the above examples show, Placeholder Names are similar to Python
expressions in the following ways:

\begin{itemize}

\item  They consist of one or more Identifiers separated by periods.  Each
     Identifier follows the same rules as a Python variable name or attribute
     name: it must start with a letter or an underscore, and the subsequent
     characters must be letters, numbers or underscores.  Identifiers are
     case-sensitive: \code{\$var} is different from \code{\$Var}.

\item  An Identifier may be followed by one or more sets of function arguments
     enclosed in ``()'' and/or key/subscript arguments in ``[]''.

\item  String literals inside argument sets must be quoted, just like in
     Python.  All Python quoting styles are allowed:  \code{'string'},
     \code{"string\n"}, \code{"""string"""}, \code{r'''string'''}.  (However,
     two bugs currently exist: Cheetah misparses \code{'Fred\'s'}, and Python's
     \code{tokenize} module misparses triple-quoted strings with embedded
     newlines.)

\end{itemize}

Placeholder Names differ from Python expressions in the following ways:

\begin{itemize}

\item  You cannot have bare variable names inside argument sets.  Instead of a
     variable name, use a Placeholder Tag.  (Yes, this means putting a
     Placeholder Tag inside a Placeholder Tag.)

\item  Operators are allowed only inside argument sets, and even there should
     be used sparingly.  This applies to the arithmetic operators (+-*/), the
     the logical operators (<, ==), etc.  You should be doing most calculations
     in Python code, not inside your templates.

\end{itemize}

If you use the optional ``{}'' around your Placeholder Names, Cheetah knows
exactly where the Placeholder Names begin and end.  If you don't, Cheetah ends
the Placeholder Name at the first character which cannot legally be a part of
it.  Complex cases may confuse Cheetah (or the human maintainer!), so when in
doubt, use the``{}''.

Cheetah knows that a dollar amount is not a Placeholder Tag, because
Placeholder Names may not begin with a digit or a hyphen.  So Cheetah will
output dollar amounts literally, as it should.  Examples:
\code{\$2.50} and \code{\$-1,234.56} (or \code{\$2,50} and \code{\$-1.234,56}
for Europeans).

To escape other words that look like Placeholder Tags but aren't, put a 
backslash before the dollar sign: (\code{$\backslash$\$variable}).  Cheetah
will output it literally.  This is useful if your document contains examples of
Perl code, because Perl variables look like Cheetah Placeholders.

If a trailing period is found (that is, a period not followed by a valid
Identifier character), Cheetah knows the \$P ends before the
period.  This is useful for \$P's at the end of a sentance.  Likewise, because
punctuation and quotes cannot occur inside a Placeholder Tag (except inside
argument sets), Placeholder Tags may be placed directly before punctuation or
quotes.

     

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Uniform Dotted Notation}

Cheetah uses what we call Uniform Dotted Notation.  This means that in
\code{\$a.b}, 'b' is not necessarily an attribute of 'a'.  'a' may be a
dictionary and 'b' one of its keys.  This allows the template maintainer to
pretend everything is an attribute, and gives the programmer some freedom to
change the implementation without having to ask the template maintainer to
change the Template Definition each time.

To use Uniform Dotted Notation with dictionaries, the key must be a legal
Identifier.  That is, it must start with a letter or an underscore, and contain
only letters, digits and/or underscores.  If the key does not fit this
limitation, you must use the \code{\$a['key lookup syntax']} instead.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Autocalling}

If the value of an Identifier is a function or a method and no ``()'' are
present, Cheetah will call it without arguments.  This is \em{autocalling}.
The purpose of autocalling is to allow the programmer to change a ``dumb
object'' (a string or number) into a ``smart object'' (a function or method
returning a string or number), or vice-versa, without the template maintainer
having to worry which objects are functions today and which are not.

In \code{\$a.b}, if 'a' is a function or a method, it must return an object
with attributes or keys, and 'b' is looked up in that object.  If 'b'
itself is a function or method, it will also be called, and the final result
will be whatever 'b' returns.

Only functions and methods are autocalled.  Other callable types--in particular
classes and instances--are never autocalled.  Calling a class or instance may
have desirable or undesirable side effects: Cheetah doesn't know!  So if you 
want to call a class or instance or another type, you must use ``()''.

Of course, if you want to pass arguments to a function or method, you have to
use ``()'' also.

If you don't like autocalling, there's a Setting to disable it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Calculating Placeholder Values}

To resolve a Placeholder Name, Cheetah looks up the first Identifier in the
first Namespace in the Search List.  If an identical Placeholder Key (which may
be an attribute or a key--Cheetah checks both) is not found, Cheetah tries the
second Namespace, and so on.

If a Namespace Key is found Cheetah takes its value (the Namespace Value) and
performs any further lookups and calls that are required: function calls,
autocalling, key/subscript lookup, and Uniform Dotted Notation lookup.  (Note
that for all Identifiers except the first, any lookups are performed only in
the preceding value, not in the Search List.) Finally, Python's \code{str()}
function is called to convert the final value to a string (the Placeholder
Value), and it's inserted into the Filled Template.

This process actually happens in two phases.  When the TO is created, and again
whenever its \code{.recompile()} method is called, Cheetah creates a little
Python function and stores it in the TO; this is called ``compiling the 
template''.  The little function calculates the Filled Template according to the
specification in the Template Definition.  Each Placeholder Tag is converted
into a Python expression that looks up the value in it's current (at compile
time) position in the Search List.

For best results, process your TO in this order:

\begin{enumerate}

\item   Create your Namespaces and assign values for each of your placeholders.
     For \code{#for} loops, build a list of objects to be looped over and
     assign this list as a Namespace Value.

\item   Create the TO, passing it the Template Definition and the Namespaces in
     order.

\item   Fill the template.  If you need only one Filled Template, you're done.

\item  If you want to produce another Filled Template, assign new values for
     your placeholders in place, using ordinary attribute assignment and key
     assignment.  (It's more convenient to make the changes using individual
     references to each Namespace object that you've kept somewhere else, 
     rather than trying to subscript the Search List.)  Avoid doing the
     ``unsafe'' operations below.  Then fill the template again.  Repeat for as
     many Filled Templates as you need.

\end{enumerate}

Templates can be nested.  A Namespace Value may be another TO.  When your TO
is filled, the inner TO will automatically be filled, and any TO's \em{it}
contains will also be filled, ad infinitum.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Unsafe'' operations}

Certain operations are ``unsafe'' after the TO has been instantiated.  These
are: moving a Namespace Key from one Namespace to another, changing the type of
a value (beyond certain limits), and adding/deleting/moving Namespaces in the
Search List. If you do any of these operations, you must recompile the template
by calling the TO's \code{.recompile()} method before filling it.  If you try
to fill the template without recompiling, you may get an error or incorrect
output.

To understand why, remember that when the TO is
compiled, Cheetah generates a Python expression that looks up the value at its
current (at compile time) location in the Search List.  Any operation that 
would require a change of syntax for this expression is ``unsafe''.  For
instance, consider \code{\$a.b}.  Assume that 'a' is found in the second 
Namespace in the Search List, that that Namespace is an instance, and 'a' is
a dictionary.  The equivalent Python expression would be \footnote{This is a
conceptual example, not the exact code Cheetah would generate.}:

\begin{verbatim}
searchList[1].a['b']
\end{verbatim}

Now move 'a' to the first Namespace (which is a dictionary), and make it a 
function returning a dictionary.  The Placeholder Tag remains the same --
\code{\$a.b} -- but the Python expression changes to something very different:

\begin{verbatim}
\code{searchList[0]['c']().d}
\end{verbatim}

Re changing the type of a value, simple changes like changing a string to an
integer is safe because it doesn't affect the lookup expression.  But 
changing a value from an autocallable type to a non-autocallable type or 
vice-versa, or changing it to or from an instance, dictionary or list, requires
recompiling the template to adjust the Python expression.

But usually, whenever you think you want to add a Namespace, move a key or
change the type of a value, you should be creating another TO instead, or
adjusting your code so that the correct Namespaces and value types are already
in place when you create the TO.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Missing values}

If there is no value defined in the Search List for a placeholder name,
Cheetah will search for an leading underscore version of the name.  For
example, if it can't find \code{\$varName} it will attempt to find
\code{\$\_varName}.  If that fails, Cheetah will include the placeholder
tag verbatim in the filled template output.

This behaviour can be customized and a default value can be set for names
that are not found. See section \ref{customizing} for more details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Caching}

By default the value of each \code{\$placeholder} is updated for each request.
If you want to statically cache the value of the \code{\$placeholder} upon
startup, add an asterisk after the \$ sign.  \code{\$var} becomes \code{\$*var}.
See the section on the \code{\#cache} directive below for more information.

If you only need to update the value of the \code{\$placeholders} at specific time intervals use
this form: \code{\$variable} becomes \code{\$*15*variable} , where 15 is the time interval in
minutes.  The time interval can also be specified in fractions of a minute such
as \code{\$*0.5*variable}.

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

$var                ## dynamic - will be reinterpolated for each request
$*var2              ## static - will be interpolated only once at start-up
$*5*var3            ## timed refresh - will be updated every 5 minutes.

</BODY>
</HTML>
\end{verbatim}


