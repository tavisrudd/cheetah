\section{Placeholder Tags (and Values)}

% Will promote subsubsections to subsections.


Cheetah's placeholder tags are equivalent to data fields in a form letter, or to
\code{\%(key)s} fields in the \code{\%} operator's format string.
In other words, placeholder tags are used as lookup keys, and are replaced by
their corresponding values when the template is filled in.
Let's look again at the example from the introduction:

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>
$contents
</BODY>
</HTML>
\end{verbatim}

When this template is filled in, the placeholders \code{\$title} and
\code{\$content} will be replaced with the values of the variables \code{title}
and \code{content}.

[MOVE DOWN
Each object's attributes and/or
keys is consulted.  If a match is found, the corresponding value is used.
If the value is a function or method, it is automatically called without
arguments.  The value is converted through a string via Python's built-in
\code{str()} method before being used.
]


\subsubsection{Rules for placeholder names}
\begin{itemize} 

\item A placeholder always has the format \code{\$name} or \code{\$\{name\}}.
     In the latter case, Cheetah knows exactly where the name begins an ends
     because it's surrounded by ``{'' and ``}'' characters.  In the former
     case, Cheetah infers where the name ends according to the rules below.  In
     complex templates that may confuse either Cheetah or the human maintainer,
     use the ``{}''.

\item The name must begin with a letter or an underscore (\_).  If it's a digit
     or a symbol, it's not a placeholder and will be output literally.  This 
     means that dollar amounts require no special treatment: \code{\$2.50}
     and \code{\$-1,234.56} (or \code{\$2,50} and \code{\$-1.234,56} for
     Europeans) will be left as is.
     
\item To prevent Cheetah from treating something that looks like a placeholder
     as a placeholder, precede it with a backslash: 
     (\code{$\backslash$\$variable}).  Cheetah will treat it as regular text.
     This is useful if your document contains examples of Perl code, for
     instance, because Perl variables look like Cheetah placeholders.

\item A placeholder name consists of one or more \bf{components} seprated by
     periods:  \code{\$a.b.c.d} .

\item Each component consists of one or more letters, digits or underscores.
     However, as we said above, the first character of the \em{first}
     component may not be a digit.  These names are valid: \code{\$a},
     \code{\$\_}, \code{\$var}, \code{\$\_var}, \code{\$var1}, \code{\$\_1var},
     \code{\$var2\_}, \code{\$dict.key}, \code{\$list.item},
     \code{\$object.method}.  These names are not: \code{\$1}, \code{\$var@2},
     \code{\$\^var}.

% Are all-numeric components allowed?  If so, need an example.

\item Each component may optionally be followed by one or more sets of 
     arguments in ``()'' or ``[]''.  Each pair of ``()'' implies a function
     call; each pair of ``[]'' implies dictionary lookup or list
     subscripting.  The format of arguments will be dealt with below.

\item names are case-sensitive. \code{\$var} does not equal \code{\$Var}
     or \code{\$vAr} or \code{\$VAR}.     
     
\item If a trailing period is found (that is, a period not followed by a valid
     component character), it is not considered part of the placeholder.  This
     is to allow placeholders at the end of sentences to be written in the 
     natural manner: \code{\$varName.  Surrounding text.} or
     \code{\$dict.key.  Surrounding text.}  In these examples, the 
     placeholder names are `varName' and `dict.key'.

\item Commas, quotation marks (single, double and backtick) and other symbols
     are never allowed in placeholder names, so they will always be treated
     as part of the surrounding text.  This is convenient for writing a 
     placeholder followed by a comma or a quotation mark.  If an illegal
     character occurs inside a ``\${}'' construct, e.g., \code{\$\{name,\}},
     it's an error.  But commas and quotes \em{are} allowed inside argument
     lists.  (Again, we'll get into argument lists more later.)

\end{itemize}
     

\subsubsection{The SearchList}

A \bf{SearchList (SL)} is simply a list of objects which will be searched to
find the values for the placeholder names.  Every Template Object
contains both a Template Definition and a SearchList.  
When you create a Template Object in Python, you provide not only a
Template Definition, but also a , which is simply a list of
objects.  Later when you invoke the template to fill it in, Cheetah resolves
the placeholders by consulting the SearchList.  For each placeholder name, it
looks up the first component in the first object in the SearchList.

Normally, the Template Object's \code{self} is the
first (and perhaps the only) item in the SearchList.  
When you later invoke a Template
Object to fill it in, Cheetah resolves each placeholder as follows:


\begin{enumerate}

\item Cheetah takes the first component in the placeholder name and looks it up
     in the first object in the SearchList.  Cheetah knows how to read both
     attributes and keys, so the object can either be an instance
     dictionary.  If the object has attributes, Cheetah looks for an attribute
     of the same name.  Otherwise Cheetah
     find a 1

\end{enumerate}

A {\bf namespace} is a Python dictionary that links names to values. Each
template definition that has been loaded into a \code{Template} objet is
associated with an ordered list of namespaces in which values for placeholder
variable names can be stored.  This list is called the {\bf searchList}.

The searchList can contain one or more namespaces.  In most cases only one
namespace will be in the searchList unless you explicitly load extra ones.  When
Cheetah fills in \code{\$content} in previous example it searchs
sequentially through the searchList until it finds a value for \code{\$content}.
Thus, if three namespaces are loaded and two of them contain a value for
\code{\$content}, the value for \code{content} from the namespace that is
closest to the start of the searchList will be returned.

If you add a Python object to the searchList, its attributes and methods will be
accessible as placeholder names.  For example, \code{myObject} contains
\code{myAttrib} and \code{myMethod}.  If \code{myObject} is added to the
searchList, \code{\$myAttrib} and \code{\$myMethod} can be used as placeholder
names.  

The default namespace in every searchList is the \code{Template} object itself.
This means that any attributes or methods that are added to classes that inherit
from \code{Template} can be accessed in templates via \code{\$placeholders}.  New
namespaces can be added to the searchList at any time using the
\code{Template.addToSearchList()} method.  See section \ref{webware} for more
information on how to use namespaces and the searchList.

\subsubsection{Placeholder values}

Placeholder names can map to Python text strings, numbers, dictionaries, lists
(arrays), functions, objects, or even nested Cheetah templates.  If the value is
not a String, Cheetah will call \code{str()} on it to obtain a string
representation that can be inserted into the template.  But if the value is a
callable object (e.g., a function or a method), Cheetah will first call it and
then call \code{str()} on the result.  You may include or omit the () after
callable placeholders: Cheetah will call it (without arguments) in either case.


\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

$aString                        ## these names are chosen to indicate what
$aNumber                        ## type of value they map to.  They could be
$aList                          ## any valid placeholder name.
$aDictionary
$aFunction
$anObject

</BODY>
</HTML>
\end{verbatim}

Note that you don't need to include () after \code{\$aFunction}.  Cheetah
will recognize callable variables like functions and methods, call them and
interpolate their return value in the filled template output.

You cannot pass arguments to a function or method called this way.  (Actually,
you can, but this feature may be removed soon, because it introduces too much
complexity that is better done in Python outside the template.)  The function or
method must either accept no arguments, or all its arguments must have default
values.  Macro calls (see the Macros section) can accept arguments, but we
aren't talking about macros here.

Templates can be nested. It is valid to embed a placeholder name that maps to
another \code{Template} object.  The filled output of the nested template will be
interpolated into the top-level template's output.  There is no limit on the
depth of template nesting.

\subsubsection{Placeholders with no value defined}
If there is no value defined in the searchList for a placeholder name,
Cheetah will search for an leading underscore version of the name.  For
example, if it can't find \code{\$varName} it will attempt to find
\code{\$_varName}.  If that fails, Cheetah will include the placeholder
tag verbatim in the filled template output.

This behaviour can be customized and a default value can be set for names
that are not found. See section \ref{customizing} for more details.

\subsubsection{Dotted notation}
Placeholder names can also use {\bf dotted notation} to access entries in
dictionaries, items in lists, and the attributes and methods of objects.
Cheetah uses a consistent dotted notation syntax to access the contents
of all types of containers.  This is unlike Python, C++, Java, and other
languages where dotted notation can only be used to access the attributes and
methods of objects. \footnote{Cheetah uses a Python module called
  NameMapper to handle this style of dotted notation.  NameMapper is distributed
  as part of the Cheetah package and can be used as a stand-alone tool.
  NameMapper was inspired by Chuck Esterbrook's NamedValueAccess module.}

\begin{verbatim}
$aDictionary.keyName            ## must be a valid key of the dictionary 
$aList.3                        ## must be a valid index (0-based like in Python)
$anObject.attributeName         ## must be a valid attribute name
$anObject.method                ## must be a valid method name, 
                                ##   leave off the parentheses on method()
\end{verbatim}


Dotted notation can be used on nested containers of any depth.
\begin{verbatim}
$dict1.dict2.dict3.keyName      ## nested dictionaries
$anObject.nestedDict.keyName    ## if the object contains a dictionary
\end{verbatim}


\subsubsection{Caching}

By default the value of each \code{\$placeholder} is updated for each request.
If you want to statically cache the value of the \code{\$placeholder} upon
startup, add an asterisk after the \$ sign.  \code{\$var} becomes \code{\$*var}.
See the section on the \code{\#cache} directive below for more information.

If you only need to update the value of the \code{\$placeholders} at specific time intervals use
this form: \code{\$variable} becomes \code{\$*15*variable} , where 15 is the time interval in
minutes.  The time interval can also be specified in fractions of a minute such
as \code{\$*0.5*variable}.

\begin{verbatim}
<HTML>
<HEAD><TITLE>$title</TITLE></HEAD>
<BODY>

$var                ## dynamic - will be reinterpolated for each request
$*var2              ## static - will be interpolated only once at start-up
$*5*var3            ## timed refresh - will be updated every 5 minutes.

</BODY>
</HTML>
\end{verbatim}

%Note that Cheetah will automatically detect nested \code{Template} objects
%and these 
%% @@finish this off

