\section{Macros}
\label{macros}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Differences between macros and functions}
%\label{macros.whatAre}

Since Macros (#M) share some superficial similarities with functions--both
accept arguments and return a string value that replaces the function call or
macro call in the Filled Template--let's look first at their differences.

Functions are evaluated every time they're called.  Macros are expended once,
at compile time.  

Macro arguments may not refer to local placeholders (those set in a
\code{\#set} or \code{\#for} directive), since they are not known at compile
time.  So it's impossible to use a macro inside a \code{\#for} loop and have
it produce a different result at each iteration: it will produce the same 
result each time, because by the time the \code{\#for} loop runs, the macro will
have already been replaced with its value.

Macros may contain any Cheetah syntax except a \code{\#macro directive}.  They
may insert placeholders, display logic, other directives, etc.  Functions may
not.  If a function returns what looks like a placeholder or a directive, it
will be output literally.

A function (or method) is always defined in Python code, using a \code{def}
statement.  The function defintion can be inside a \code{\#data} section in
a template definition, in a subclass of Template (as a method), or in the
module that uses the template.  The function should have a \code{return}
statement that returns the text to be inserted into the Filled Template.

A macro is usually defined using the \code{#macro} directive.  However, it is
possible to write a Python function and register it as a Cheetah macro.
Examples of both are below.  Using the \code{\#macro} directive is more
convenient if your macro consists mostly of text to be inserted with occasional
placeholders.  Loading it from a function is the only choice if you must do
calculations, because you cannot do calculations inside a \code{#macro}
directive body.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Calling macros}
\label{macros.calling}

To call a macro that has already been defined, use the following syntax:
\code{\#MyMacro(ARGUMENTS)}.  The argument syntax is the same as for function
arguments: Python expressions separated by commas, using placeholders instead
of variable names.  The ``()'' are required even if there are no arguments.
Unlike other directives, a \code{#M} ends immediately at the closing ``$\)$'';
there is no such thing as a ``/#'' after a macro call.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Defining macros using \code{#macro}}
\label{macros.definingMacros}

A macro definition looks like this:

\begin{verbatim}
#macro macroName(ARGUMENTS)
Body of the macro, which may include $placeholders and
directives like #slurp
.
#end macro
\end{verbatim}

When the macro is called, it will insert the body of the macro in the 
template.  (Remember, this happens at compile time.)  Placeholders referring to
macro arguments are expanded, as are permanently-cached placeholders.
Dynamic or timed-refresh placeholders are left as is to be expanded when the TO
is filled.  Macros inside macros are recursively expanded.  Other directives 
are left alone, to be evaluated when the TO is filled.

The formal arguments in a macro definition are in Python syntax.  This means
\em{variable names}, not placeholders.  Default values for arguments may be
provided in the usual Python manner.

Here's a longish example of a macro definition from 
\bf{examples/webware\examples/cheetahSite/SiteTemplate.tmpl}:

\begin{verbatim}
#macro insetBox(width=170, boxTitle='', boxContents='')
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=$width>
  <TR>
    <TD COLSPAN=3 HEIGHT=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
    <TD WIDTH=900 HEIGHT=1 BGCOLOR="$mainTbl.outerFrameColor">#spacer()</TD> ## force full width 
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
    <TD WIDTH=900 HEIGHT=1 BGCOLOR="$mainTbl.innerFrameColor">  ## force full width 
       <DIV CLASS="insetBoxTitleContainer"><DIV CLASS="insetBoxTitle">$boxTitle</DIV></DIV>
    </TD>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
    <TD WIDTH=900 HEIGHT=1 BGCOLOR="$mainTbl.outerFrameColor">#spacer()</TD> ## force full width 
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
  <TR>
    <TD COLSPAN=3 HEIGHT=1 BGCOLOR="$*insetBoxes.titleFrameColor">#spacer()</TD>
  </TR>
</TABLE>
	    
<TABLE VALIGN="top" WIDTH=$*width BORDER=0 CELLPADDING=0 CELLSPACING=0>
  <TR>
    <TD WIDTH=1 bgcolor="$*insetBoxes.frameColor">#spacer()</TD>
    <TD WIDTH=900 BGCOLOR="$*insetBoxes.bgcolor">  ## force to full width 
    ## now begin the contents cell of the insetBox
    $boxContents
    ## end insetBox	
    </TD>
    <TD WIDTH=1 BGCOLOR="$*insetBoxes.frameColor">#spacer()</TD>
  </TR>
</TABLE>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=$width>
  <TR>
    <TD HEIGHT=1 BGCOLOR="$*insetBoxes.frameColor">#spacer()</TD>
  </TR>
</TABLE>
#end macro
\end{verbatim}

All the formal arguments in the \code{\#insetBox} macro have default values, so
they don't have to be specified when the macro is called.  Notice how the 
author uses different placeholder styles according to the placeholder.  Most
placeholders have a ``*'' for permanent caching.  Those referring to macro
arguments don't have a ``*'' (that would be silly), as do a few dynamic
placeholders (e.g., \code{\$insetBoxes.titleFrameColor}, which is not defined in
the macro but is assumed to exist when the template is filled.  Notice also
how the author calls macros inside macros (e.g., \code{#spacer()}).

% Can a macro be redefined?


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Defining macros from functions}

A Python function may also be registered as a Cheetah macro.  To do this,
execute one of these statements in your Template subclass or in a 
\code{\#data} section.  The functions must have already been defined or 
imported.

\begin{verbatim}
# Create a macro called 'macroName' containing the code from 'function'.
self.loadMacro('macroName', function)

# Create macros from functions named 'spacer' and 'formHTMLTag'.  Each macro
# will have the same name as its function.
self.loadMacros(spacer, formHTMLTag)

# Create macros from all the callable objects in module 'Cheetah.Macros.HTML'.
# If the module has an attribute '\_exclusionList', it is a list of objects
# (not names) which will be skipped in the macrofying process.
self.loadMacrosFromModule(Cheetah.Macros.HTML)
\end{verbatim}

That last command is especially useful, since the \code{Cheetah.Macros.HTML}
module comes with Cheetah and includes a variety of macros useful in web
pages.  The \code{Cheetah.Macros} package may also include some other macro
modules by the time you read this.

Because the functions these macros are loaded from really \em{are} functions,
they can also be loaded into the Search List and used as placeholder functions:

\begin{verbatim}
templateObj = Template(Cheetah.Macros.HTML)
\end{verbatim}

There's no confusion here because \code{\$spacer(50)} will get the function and
\code{#spacer(50)} will get the macro.  Just remember that if the macro
outputs embedded macros, directives or placeholders (except the placeholders
representing the macro's arguments), it cannot be used as a placeholder
function.  Or rather it can, but the \code{\$P}, \code{\#D} and \code{\#M}
won't be expanded.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Macro libraries}
\label{macros.libraries}

Cheetah comes ``batteries included'', with a library of useful macros in the
\code{Cheetah.Macros} package.  
