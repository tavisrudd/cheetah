#!/usr/bin/env python
# $Id: Delimiters.py,v 1.10 2001/08/11 04:57:39 tavis_rudd Exp $
"""A dictionary of delimeter regular expressions that are used in Cheetah

Meta-Data
================================================================================
Author: Tavis Rudd <tavis@calrudd.com>
License: This software is released for unlimited distribution under the
         terms of the Python license.
Version: $Revision: 1.10 $
Start Date: 2001/03/30
Last Revision Date: $Date: 2001/08/11 04:57:39 $
"""
__author__ = "Tavis Rudd <tavis@calrudd.com>"
__version__ = "$Revision: 1.10 $"[11:-2]


##################################################
## DEPENDENCIES ##

import re

##################################################
### CONSTANTS & GLOBALS ###

escCharLookBehind = r'(?:(?<=\A)|(?<!\\))'
tagClosure = r'(?:/#|\r\n|\n|\r)'
lazyTagClosure = r'(?:\r\n|\n|\r)'

delimiters = {
    '[%,%]':re.compile(r"\[%(.+?)%\]",re.DOTALL),
    '{,}':re.compile(r"{(.+?)}",re.DOTALL),
    '<%,%>':re.compile(r"<%(.+?)%>",re.DOTALL),

    # the suffix _gobbleWS stands for gobble whitespace - any directive on a
    # line by itself will have all preceeding and trailing WS on that line
    # gobbled up with the directive

    'displayLogic_gobbleWS': re.compile(r'(?:\A|^)[\t ]*#(' +
                                        r'if[\t ]+[^(?:/#)]+?|' +
                                        r'else[\t ]*?|' +
                                        r'else[\t ]if[\t ]+[^(?:/#)]+?|' +
                                        r'elif[\t ]+[^(?:/#)]+?|' +
                                        r'for[\t ][^(?:/#)]+?|' +
                                        r'continue|' +
                                        r'break|' +
                                        r'end if|' +
                                        r'end for|' +
                                        r')[\t ]*(?:\r\n|\n|\r|\Z)',
                                        re.MULTILINE
                                        ),
    'displayLogic': re.compile(escCharLookBehind + r'#(' +
                               r'if[\t ]+.+?|' +
                               r'else[\t ]*?|' +
                               r'else[\t ]if[\t ]+.+?|' +
                               r'elif[\t ]+.+?|' +
                               r'for[\t ].+?|' +
                               r'end if|' +
                               r'end for|' +
                               r')[\t ]*(?:/#|\r\n|\n|\r|\Z)',
                               re.MULTILINE
                               ),

    # the block directives are handled differently from the macro directives, etc.
    # to avoid maximum recursion limit errors when the content of the block is
    # large.  The end tag is dynamically generated by the blockDirective processor

    'extendDirective':re.compile(escCharLookBehind + r'#extend[\t ]+(?P<parent>.*?)' +
                                 r'[\t ]*(?:/#|\r\n|\n|\r|\Z)', re.DOTALL),
    }



